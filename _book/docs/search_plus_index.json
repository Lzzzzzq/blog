{"./":{"url":"./","title":"简介","keywords":"","body":"简介 记录各种鬼东西 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/js/":{"url":"articles/js/","title":"js","keywords":"","body":"js Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/js/prototype.html":{"url":"articles/js/prototype.html","title":"proto 和 prototype 的关系","keywords":"","body":"proto 和 prototype 的关系 经常有看到对于 proto 和 prototype 的总结，现整理一下 function Foo () {} let foo = new Foo() // Foo 为 foo 的构造函数 foo.__proto__ === Foo.prototype foo.constructor === Foo // Function 为 Foo 的构造函数 Foo.__proto__ === Function.prototype Foo.constructor === Function // Function 由自己创建 Function.__proto__ === Function.prototype Function.constructor === Function // 所有构造函数的 prototype.__proto__ 都指向 Object.prototype Function.prototype.__proto__ === Object.prototype Foo.prototype.__proto__ === Object.prototype Function.prototype.__proto__.constructor === Object // Object.prototype 为所有函数的源头，它的 __proto__ 为 null Object.prototype.__proto__ === null let obj = {} obj.__proto__ === Object.prototype obj.__proto__.__proto__ === null obj.__proto__.constructor === Object obj.__proto__.constructor.__proto__ === Object.__proto__ obj.__proto__.constructor.__proto__.__proto__ === Object.prototype Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/react/":{"url":"articles/react/","title":"React","keywords":"","body":"react Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:47:48 "},"articles/react/react-as-a-ui-runtime.html":{"url":"articles/react/react-as-a-ui-runtime.html","title":"[转] 将 React 作为 UI 运行时","keywords":"","body":"将 React 作为 UI 运行时 本文转自：https://overreacted.io/zh-hans/react-as-a-ui-runtime/ 大多数教程把 React 称作是一个 UI 库。这是有道理的，因为 React 就是一个 UI 库。正如官网上的标语所说的那样。 我曾经写过关于构建用户界面会遇到的难题一文。但是本篇文章将以一种不同的方式来讲述 React — 因为它更像是一种编程运行时。 本篇文章不会教你任何有关如何创建用户界面的技巧。 但是它可能会帮助你更深入地理解 React 编程模型。 注意：如果你还在学习 React ，请移步到官方文档进行学习 ⚠️ 本篇文章将会非常深入 — 所以并不适合初学者阅读。 在本篇文章中，我会从最佳原则的角度尽可能地阐述 React 编程模型。我不会解释如何使用它 — 而是讲解它的原理。 文章面向有经验的程序员和那些使用过其他 UI 库但在项目中权衡利弊后最终选择了 React 的人，我希望它会对你有所帮助！ 许多人成功使用了 React 多年却从未考虑过下面我将要讲述的主题。 这肯定是从程序员的角度来看待 React ，而不是以设计者的角度。但我并不认为站在两个不同的角度来重新认识 React 会有什么坏处。 话不多说，让我们开始深入理解 React 吧！ 宿主树 一些程序输出数字。另一些程序输出诗词。不同的语言和它们的运行时通常会对特定的一组用例进行优化，而 React 也不例外。 React 程序通常会输出一棵会随时间变化的树。 它有可能是一棵 DOM 树 ，iOS 视图层，PDF 原语 ，又或是 JSON 对象 。然而，通常我们希望用它来展示 UI 。我们称它为“宿主树”，因为它往往是 React 之外宿主环境中的一部分 — 就像 DOM 或 iOS 。宿主树通常有它自己的命令式 API 。而 React 就是它上面的那一层。 所以到底 React 有什么用呢？非常抽象地，它可以帮助你编写可预测的，并且能够操控复杂的宿主树进而响应像用户交互、网络响应、定时器等外部事件的应用程序。 当专业的工具可以施加特定的约束且能从中获益时，它比一般的工具要好。React 就是这样的典范，并且它坚持两个原则： 稳定性。 宿主树是相对稳定的，大多数情况的更新并不会从根本上改变其整体结构。如果应用程序每秒都会将其所有可交互的元素重新排列为完全不同的组合，那将会变得难以使用。那个按钮去哪了？为什么我的屏幕在跳舞？ 通用性。 宿主树可以被拆分为外观和行为一致的 UI 模式（例如按钮、列表和头像）而不是随机的形状。 这些原则恰好适用于大多数 UI 。 然而，当输出没有稳定的“模式”时 React 并不适用。例如，React 也许可以帮助你编写一个 Twitter 客户端，但对于一个 3D 管道屏幕保护程序 并不会起太大作用。 宿主实例 宿主树由节点组成，我们称之为“宿主实例”。 在 DOM 环境中，宿主实例就是我们通常所说的 DOM 节点 — 就像当你调用 document.createElement('div') 时获得的对象。在 iOS 中，宿主实例可以是从 JavaScript 到原生视图唯一标识的值。 宿主实例有它们自己的属性（例如 domNode.className 或者 view.tintColor ）。它们也有可能将其他的宿主实例作为子项。 （这和 React 没有任何联系 — 因为我在讲述宿主环境。） 通常会有原生的 API 用于操控这些宿主实例。例如，在 DOM 环境中会提供像 appendChild、removeChild、setAttribute 等一系列的 API 。在 React 应用中，通常你不会调用这些 API ，因为那是 React 的工作。 渲染器 渲染器教会 React 如何与特定的宿主环境通信以及如何管理它的宿主实例。React DOM、React Native 甚至 Ink 都可以称作 React 渲染器。你也可以创建自己的 React 渲染器 。 React 渲染器能以下面两种模式之一进行工作。 绝大多数渲染器都被用作“突变”模式。这种模式正是 DOM 的工作方式：我们可以创建一个节点，设置它的属性，在之后往里面增加或者删除子节点。宿主实例是完全可变的。 但 React 也能以”不变“模式工作。这种模式适用于那些并不提供像 appendChild 的 API 而是克隆双亲树并始终替换掉顶级子树的宿主环境。在宿主树级别上的不可变性使得多线程变得更加容易。React Fabric 就利用了这一模式。 作为 React 的使用者，你永远不需要考虑这些模式。我只想强调 React 不仅仅只是从一种模式转换到另一种模式的适配器。它的用处在于以一种更好的方式操控宿主实例而不用在意那些低级视图 API 范例。 React 元素 在宿主环境中，一个宿主实例（例如 DOM 节点）是最小的构建单元。而在 React 中，最小的构建单元是 React 元素。 React 元素是一个普通的 JavaScript 对象。它用来描述一个宿主实例。 // JSX 是用来描述这些对象的语法糖。 // { type: 'button', props: { className: 'blue' } } React 元素是轻量级的因为没有宿主实例与它绑定在一起。同样的，它只是对你想要在屏幕上看到的内容的描述。 就像宿主实例一样，React 元素也能形成一棵树： // JSX 是用来描述这些对象的语法糖。 // // // // { type: 'dialog', props: { children: [{ type: 'button', props: { className: 'blue' } }, { type: 'button', props: { className: 'red' } }] } } (注意：我省略了一些对此解释不重要的属性) 但是，请记住 React 元素并不是永远存在的 。它们总是在重建和删除之间不断循环着。 React 元素具有不可变性。例如，你不能改变 React 元素中的子元素或者属性。如果你想要在稍后渲染一些不同的东西，你需要从头创建新的 React 元素树来描述它。 我喜欢将 React 元素比作电影中放映的每一帧。它们捕捉 UI 在特定的时间点应该是什么样子。它们永远不会再改变。 入口 每一个 React 渲染器都有一个“入口”。正是那个特定的 API 让我们告诉 React ，将特定的 React 元素树渲染到真正的宿主实例中去。 例如，React DOM 的入口就是 ReactDOM.render ： ReactDOM.render( // { type: 'button', props: { className: 'blue' } } , document.getElementById('container') ); 当我们调用 ReactDOM.render(reactElement, domContainer) 时，我们的意思是：“亲爱的 React ，将我的 reactElement 映射到 domContaienr 的宿主树上去吧。“ React 会查看 reactElement.type （在我们的例子中是 button ）然后告诉 React DOM 渲染器创建对应的宿主实例并设置正确的属性： // 在 ReactDOM 渲染器内部（简化版） function createHostInstance(reactElement) { let domNode = document.createElement(reactElement.type); domNode.className = reactElement.props.className; return domNode; } 在我们的例子中，React 会这样做： let domNode = document.createElement('button'); domNode.className = 'blue'; domContainer.appendChild(domNode); 如果 React 元素在 reactElement.props.children 中含有子元素，React 会在第一次渲染中递归地为它们创建宿主实例。 协调 如果我们用同一个 container 调用 ReactDOM.render() 两次会发生什么呢？ ReactDOM.render( , document.getElementById('container') ); // ... 之后 ... // 应该替换掉 button 宿主实例吗？ // 还是在已有的 button 上更新属性？ ReactDOM.render( , document.getElementById('container') ); 同样的，React 的工作是将 React 元素树映射到宿主树上去。确定该对宿主实例做什么来响应新的信息有时候叫做协调 。 有两种方法可以解决它。简化版的 React 会丢弃已经存在的树然后从头开始创建它： let domContainer = document.getElementById('container'); // 清除掉原来的树 domContainer.innerHTML = ''; // 创建新的宿主实例树 let domNode = document.createElement('button'); domNode.className = 'red'; domContainer.appendChild(domNode); 但是在 DOM 环境下，这样的做法效率低下而且会丢失像 focus、selection、scroll 等许多状态。相反，我们希望 React 这样做： let domNode = domContainer.firstChild; // 更新已有的宿主实例 domNode.className = 'red'; 换句话说，React 需要决定何时更新一个已有的宿主实例来匹配新的 React 元素，何时该重新创建新的宿主实例。 这就引出了一个识别问题。React 元素可能每次都不相同，到底什么时候才该从概念上引用同一个宿主实例呢？ 在我们的例子中，它很简单。我们之前渲染了 作为第一个（也是唯一）的子元素，接下来我们想要在同一个地方再次渲染 。在宿主实例中我们已经有了一个 为什么还要重新创建呢？让我们重用它。 这与 React 如何思考并解决这类问题已经很接近了。 如果相同的元素类型在同一个地方先后出现两次，React 会重用已有的宿主实例。 这里有一个例子，其中的注释大致解释了 React 是如何工作的： // let domNode = document.createElement('button'); // domNode.className = 'blue'; // domContainer.appendChild(domNode); ReactDOM.render( , document.getElementById('container') ); // 能重用宿主实例吗？能！(button → button)// domNode.className = 'red';ReactDOM.render( , document.getElementById('container') ); // 能重用宿主实例吗？不能！(button → p)// domContainer.removeChild(domNode); // domNode = document.createElement('p'); // domNode.textContent = 'Hello'; // domContainer.appendChild(domNode); ReactDOM.render( Hello, document.getElementById('container') ); // 能重用宿主实例吗？能！(p → p)// domNode.textContent = 'Goodbye';ReactDOM.render( Goodbye, document.getElementById('container') ); 同样的启发式方法也适用于子树。例如，当我们在 中新增两个 ，React 会先决定是否要重用 ，然后为每一个子元素重复这个决定步骤。 条件 如果 React 在渲染更新前后只重用那些元素类型匹配的宿主实例，那当遇到包含条件语句的内容时又该如何渲染呢？ 假设我们只想首先展示一个输入框，但之后要在它之前渲染一条信息： // 第一次渲染 ReactDOM.render( , domContainer ); // 下一次渲染 ReactDOM.render( I was just added here! , domContainer ); 在这个例子中， 宿主实例会被重新创建。React 会遍历整个元素树，并将其与先前的版本进行比较： dialog → dialog ：能重用宿主实例吗？能 — 因为类型是匹配的。 input → p ：能重用宿主实例吗？不能，类型改变了！ 需要删除已有的 input 然后重新创建一个 p 宿主实例。 (nothing) → input ：需要重新创建一个 input 宿主实例。 因此，React 会像这样执行更新： let oldInputNode = dialogNode.firstChild;dialogNode.removeChild(oldInputNode); let pNode = document.createElement('p'); pNode.textContent = 'I was just added here!'; dialogNode.appendChild(pNode); let newInputNode = document.createElement('input'); dialogNode.appendChild(newInputNode); 这样的做法并不科学因为事实上 并没有被 所替代 — 它只是移动了位置而已。我们不希望因为重建 DOM 而丢失了 selection、focus 等状态以及其中的内容。 虽然这个问题很容易解决（在下面我会马上讲到），但这个问题在 React 应用中并不常见。而当我们探讨为什么会这样时却很有意思。 事实上，你很少会直接调用 ReactDOM.render 。相反，在 React 应用中程序往往会被拆分成这样的函数： function Form({ showMessage }) { let message = null; if (showMessage) { message = I was just added here!; } return ( {message} ); } 这个例子并不会遇到刚刚我们所描述的问题。让我们用对象注释而不是 JSX 也许可以更好地理解其中的原因。来看一下 dialog 中的子元素树： function Form({ showMessage }) { let message = null; if (showMessage) { message = { type: 'p', props: { children: 'I was just added here!' } }; } return { type: 'dialog', props: { children: [ message, { type: 'input', props: {} } ] } }; } 不管 showMessage 是 true 还是 false ，在渲染的过程中 总是在第二个孩子的位置且不会改变。 如果 showMessage 从 false 改变为 true ，React 会遍历整个元素树，并与之前的版本进行比较： dialog → dialog ：能够重用宿主实例吗？能 — 因为类型匹配。 (null) → p ：需要插入一个新的 p 宿主实例。 input → input ：能够重用宿主实例吗？能 — 因为类型匹配。 之后 React 大致会像这样执行代码： let inputNode = dialogNode.firstChild; let pNode = document.createElement('p'); pNode.textContent = 'I was just added here!'; dialogNode.insertBefore(pNode, inputNode); 这样一来输入框中的状态就不会丢失了。 列表 比较树中同一位置的元素类型对于是否该重用还是重建相应的宿主实例往往已经足够。 但这只适用于当子元素是静止的并且不会重排序的情况。在上面的例子中，即使 message 不存在，我们仍然知道输入框在消息之后，并且再没有其他的子元素。 而当遇到动态列表时，我们不能确定其中的顺序总是一成不变的。 function ShoppingList({ list }) { return ( {list.map(item => ( You bought {item.name} Enter how many do you want: ))} ) } 如果我们的商品列表被重新排序了，React 只会看到所有的 p 以及里面的 input 拥有相同的类型，并不知道该如何移动它们。（在 React 看来，虽然这些商品本身改变了，但是它们的顺序并没有改变。） 所以 React 会对这十个商品进行类似如下的重排序： for (let i = 0; i React 只会对其中的每个元素进行更新而不是将其重新排序。这样做会造成性能上的问题和潜在的 bug 。例如，当商品列表的顺序改变时，原本在第一个输入框的内容仍然会存在于现在的第一个输入框中 — 尽管事实上在商品列表里它应该代表着其他的商品！ 这就是为什么每次当输出中包含元素数组时，React 都会让你指定一个叫做 key 的属性： function ShoppingList({ list }) { return ( {list.map(item => ( You bought {item.name} Enter how many do you want: ))} ) } key 给予 React 判断子元素是否真正相同的能力，即使在渲染前后它在父元素中的位置不是相同的。 当 React 在 中发现 ，它就会检查之前版本中的 是否同样含有 。即使 中的子元素们改变位置后，这个方法同样有效。在渲染前后当 key 仍然相同时，React 会重用先前的宿主实例，然后重新排序其兄弟元素。 需要注意的是 key 只与特定的父亲 React 元素相关联，比如 。React 并不会去匹配父元素不同但 key 相同的子元素。（React 并没有惯用的支持对在不重新创建元素的情况下让宿主实例在不同的父元素之间移动。） 给 key 赋予什么值最好呢？最好的答案就是：什么时候你会说一个元素不会改变即使它在父元素中的顺序被改变？ 例如，在我们的商品列表中，商品本身的 ID 是区别于其他商品的唯一标识，那么它就最适合作为 key 。 组件 我们已经知道函数会返回 React 元素： function Form({ showMessage }) { let message = null; if (showMessage) { message = I was just added here!; } return ( {message} ); } 这些函数被叫做组件。它们让我们可以打造自己的“工具箱”，例如按钮、头像、评论框等等。组件就像 React 的面包和黄油。 组件接受一个参数 — 对象哈希。它包含“props”（“属性”的简称）。在这里 showMessage 就是一个 prop 。它们就像是具名参数一样。 纯净 React 组件中对于 props 应该是纯净的。 function Button(props) { // &#x1F534; 没有作用 props.isActive = true; } 通常来说，突变在 React 中不是惯用的。（我们会在之后讲解如何用更惯用的方式来更新 UI 以响应事件。） 不过，局部的突变是绝对允许的： function FriendList({ friends }) { let items = []; for (let i = 0; i ); } return {items}; } 当我们在函数组件内部创建 items 时不管怎样改变它都行，只要这些突变发生在将其作为最后的渲染结果之前。所以并不需要重写你的代码来避免局部突变。 同样地，惰性初始化是被允许的即使它不是完全“纯净”的： function ExpenseForm() { // 只要不影响其他组件这是被允许的： SuperCalculator.initializeIfNotReady(); // 继续渲染...... } 只要调用组件多次是安全的，并且不会影响其他组件的渲染，React 并不关心你的代码是否像严格的函数式编程一样百分百纯净。在 React 中，幂等性比纯净性更加重要。 也就是说，在 React 组件中不允许有用户可以直接看到的副作用。换句话说，仅调用函数式组件时不应该在屏幕上产生任何变化。 递归 我们该如何在组件中使用组件？组件属于函数因此我们可以直接进行调用： let reactElement = Form({ showMessage: true }); ReactDOM.render(reactElement, domContainer); 然而，在 React 运行时中这并不是惯用的使用组件的方式。 相反，使用组件惯用的方式与我们已经了解的机制相同 — 即 React 元素。这意味着不需要你直接调用组件函数，React 会在之后为你做这件事情： // { type: Form, props: { showMessage: true } } let reactElement = ; ReactDOM.render(reactElement, domContainer); 然后在 React 内部，你的组件会这样被调用： // React 内部的某个地方 let type = reactElement.type; // Form let props = reactElement.props; // { showMessage: true } let result = type(props); // 无论 Form 会返回什么 组件函数名称按照规定需要大写。当 JSX 转换时看见 而不是 ，它让对象 type 本身成为标识符而不是字符串： console.log(.type); // 'form' 字符串 console.log(.type); // Form 函数 我们并没有全局的注册机制 — 字面上当我们输入 时代表着 Form 。如果 Form在局部作用域中并不存在，你会发现一个 JavaScript 错误，就像平常你使用错误的变量名称一样。 因此，当元素类型是一个函数的时候 React 会做什么呢？它会调用你的组件，然后询问组件想要渲染什么元素。 这个步骤会递归式地执行下去，更详细的描述在这里 。总的来说，它会像这样执行： 你： ReactDOM.render(, domContainer) React： App ，你想要渲染什么？ App ：我要渲染包含 的 。 React： ，你要渲染什么？ Layout ：我要在 中渲染我的子元素。我的子元素是 所以我猜它应该渲染到 中去。 React： ，你要渲染什么？ ：我要在 中渲染一些文本和 。 React： ，你要渲染什么？ ：我要渲染含有文本的 。 React： 好的，让我们开始吧： // 最终的 DOM 结构 Some text some more text 这就是为什么我们说协调是递归式的。当 React 遍历整个元素树时，可能会遇到元素的 type 是一个组件。React 会调用它然后继续沿着返回的 React 元素下行。最终我们会调用完所有的组件，然后 React 就会知道该如何改变宿主树。 在之前已经讨论过的相同的协调准则，在这一样适用。如果在同一位置的 type 改变了（由索引和可选的 key 决定），React 会删除其中的宿主实例并将其重建。 控制反转 你也许会好奇：为什么我们不直接调用组件？为什么要编写 而不是 Form()？ React 能够做的更好如果它“知晓”你的组件而不是在你递归调用它们之后生成的 React 元素树。 // &#x1F534; React 并不知道 Layout 和 Article 的存在。 // 因为你在调用它们。 ReactDOM.render( Layout({ children: Article() }), domContainer ) // ✅ React知道 Layout 和 Article 的存在。 // React 来调用它们。 ReactDOM.render( , domContainer ) 这是一个关于控制反转的经典案例。通过让 React 调用我们的组件，我们会获得一些有趣的属性： 组件不仅仅只是函数。 React 能够用在树中与组件本身紧密相连的局部状态等特性来增强组件功能。优秀的运行时提供了与当前问题相匹配的基本抽象。就像我们已经提到过的，React 专门针对于那些渲染 UI 树并且能够响应交互的应用。如果你直接调用了组件，你就只能自己来构建这些特性了。 组件类型参与协调。 通过 React 来调用你的组件，能让它了解更多关于元素树的结构。例如，当你从渲染 页面转到 Profile 页面，React 不会尝试重用其中的宿主实例 — 就像你用 替换掉 一样。所有的状态都会丢失 — 对于渲染完全不同的视图时，通常来说这是一件好事。你不会想要在 和 之间保留输入框的状态尽管 的位置意外地“排列”在它们之间。 React 能够推迟协调。 如果让 React 控制调用你的组件，它能做很多有趣的事情。例如，它可以让浏览器在组件调用之间做一些工作，这样重渲染大体量的组件树时就不会阻塞主线程。想要手动编排这个过程而不依赖 React 的话将会十分困难。 更好的可调试性。 如果组件是库中所重视的一等公民，我们就可以构建丰富的开发者工具，用于开发中的自省。 让 React 调用你的组件函数还有最后一个好处就是惰性求值。让我们看看它是什么意思。 惰性求值 当我们在 JavaScript 中调用函数时，参数往往在函数调用之前被执行。 // (2) 它会作为第二个计算 eat( // (1) 它会首先计算 prepareMeal() ); 这通常是 JavaScript 开发者所期望的因为 JavaScript 函数可能有隐含的副作用。如果我们调用了一个函数，但直到它的结果不知怎地被“使用”后该函数仍没有执行，这会让我们感到十分诧异。 但是，React 组件是相对纯净的。如果我们知道它的结果不会在屏幕上出现，则完全没有必要执行它。 考虑下面这个含有 的 组件： function Story({ currentUser }) { // return { // type: Page, // props: { // user: currentUser, // children: { type: Comments, props: {} } // } // } return ( ); } 组件能够在 中渲染传递给它的子项： function Page({ currentUser, children }) { return ( {children} ); } (在 JSX 中 和 } />相同。) 但是要是存在提前返回的情况呢？ function Page({ currentUser, children }) { if (!currentUser.isLoggedIn) { return Please login; } return ( {children} ); } 如果我们像函数一样调用 Comments() ，不管 Page 是否想渲染它们都会被立即执行： // { // type: Page, // props: { // children: Comments() // 总是调用！// } // } {Comments()} 但是如果我们传递的是一个 React 元素，我们不需要自己执行 Comments ： // { // type: Page, // props: { // children: { type: Comments }// } // } 让 React 来决定何时以及是否调用组件。如果我们的的 Page 组件忽略自身的 childrenprop 且相反地渲染了 Please login ，React 不会尝试去调用 Comments 函数。重点是什么？ 这很好，因为它既可以让我们避免不必要的渲染也能使我们的代码变得不那么脆弱。（当用户退出登录时，我们并不在乎 Comments 是否被丢弃 — 因为它从没有被调用过。） 状态 我们先前提到过关于协调和在树中元素概念上的“位置”是如何让 React 知晓是该重用宿主实例还是该重建它。宿主实例能够拥有所有相关的局部状态：focus、selection、input 等等。我们想要在渲染更新概念上相同的 UI 时保留这些状态。我们也想可预测性地摧毁它们，当我们在概念上渲染的是完全不同的东西时（例如从 转换到 ）。 局部状态是如此有用，以至于 React 让你的组件也能拥有它。 组件仍然是函数但是 React 用对构建 UI 有好处的许多特性增强了它。在树中每个组件所绑定的局部状态就是这些特性之一。 我们把这些特性叫做 Hooks 。例如，useState 就是一个 Hook 。 function Example() { const [count, setCount] = useState(0); return ( You clicked {count} times setCount(count + 1)}> Click me ); } 它返回一对值：当前的状态和更新该状态的函数。 数组的解构语法让我们可以给状态变量自定义名称。例如，我在这里称它们为 count 和 setCount ，但是它们也可以被称作 banana 和 setBanana 。在这些文字之下，我们会用 setState 来替代第二个值无论它在具体的例子中被称作什么。 (你能在 React 文档 中学习到更多关于 useState 和 其他 Hooks 的知识。) 一致性 即使我们想将协调过程本身分割成非阻塞的工作块，我们仍然需要在同步的循环中对真实的宿主实例进行操作。这样我们才能保证用户不会看见半更新状态的 UI ，浏览器也不会对用户不应看到的中间状态进行不必要的布局和样式的重新计算。 这也是为什么 React 将所有的工作分成了”渲染阶段“和”提交阶段“的原因。渲染阶段 是当 React 调用你的组件然后进行协调的时段。在此阶段进行干涉是安全的且在未来这个阶段将会变成异步的。提交阶段 就是 React 操作宿主树的时候。而这个阶段永远是同步的。 缓存 当父组件通过 setState 准备更新时，React 默认会协调整个子树。因为 React 并不知道在父组件中的更新是否会影响到其子代，所以 React 默认保持一致性。这听起来会有很大的性能消耗但事实上对于小型和中型的子树来说，这并不是问题。 当树的深度和广度达到一定程度时，你可以让 React 去缓存子树并且重用先前的渲染结果当 prop 在浅比较之后是相同时： function Row({ item }) { // ... } export default React.memo(Row); 现在，在父组件 中调用 setState 时如果 中的 item 与先前渲染的结果是相同的，React 就会直接跳过协调的过程。 你可以通过 useMemo() Hook 获得单个表达式级别的细粒度缓存。该缓存于其相关的组件紧密联系在一起，并且将与局部状态一起被销毁。它只会保留最后一次计算的结果。 默认情况下，React 不会故意缓存组件。许多组件在更新的过程中总是会接收到不同的 props ，所以对它们进行缓存只会造成净亏损。 原始模型 令人讽刺地是，React 并没有使用“反应式”的系统来支持细粒度的更新。换句话说，任何在顶层的更新只会触发协调而不是局部更新那些受影响的组件。 这样的设计是有意而为之的。对于 web 应用来说交互时间是一个关键指标，而通过遍历整个模型去设置细粒度的监听器只会浪费宝贵的时间。此外，在很多应用中交互往往会导致或小（按钮悬停）或大（页面转换）的更新，因此细粒度的订阅只会浪费内存资源。 React 的设计原则之一就是它可以处理原始数据。如果你拥有从网络请求中获得的一组 JavaScript 对象，你可以将其直接交给组件而无需进行预处理。没有关于可以访问哪些属性的问题，或者当结构有所变化时造成的意外的性能缺损。React 渲染是 O(视图大小) 而不是 O(模型大小) ，并且你可以通过 windowing 显著地减少视图大小。 有那么一些应用细粒度订阅对它们来说是有用的 — 例如股票代码。这是一个极少见的例子，因为“所有的东西都需要在同一时间内持续更新”。虽然命令式的方法能够优化此类代码，但 React 并不适用于这种情况。同样的，如果你想要解决该问题，你就得在 React 之上自己实现细粒度的订阅。 注意，即使细粒度订阅和“反应式”系统也无法解决一些常见的性能问题。 例如，渲染一棵很深的树（在每次页面转换的时候发生）而不阻塞浏览器。改变跟踪并不会让它变得更快 — 这样只会让其变得更慢因为我们执行了额外的订阅工作。另一个问题是我们需要等待返回的数据在渲染视图之前。在 React 中，我们用并发渲染来解决这些问题。 批量更新 一些组件也许想要更新状态来响应同一事件。下面这个例子是假设的，但是却说明了一个常见的模式： function Parent() { let [count, setCount] = useState(0); return ( setCount(count + 1)}> Parent clicked {count} times ); } function Child() { let [count, setCount] = useState(0); return ( setCount(count + 1)}> Child clicked {count} times ); } 当事件被触发时，子组件的 onClick 首先被触发（同时触发了它的 setState ）。然后父组件在它自己的 onClick 中调用 setState 。 如果 React 立即重渲染组件以响应 setState 调用，最终我们会重渲染子组件两次： *** 进入 React 浏览器 click 事件处理过程 *** Child (onClick) - setState - re-render Child // &#x1F61E; 不必要的重渲染Parent (onClick) - setState - re-render Parent - re-render Child*** 结束 React 浏览器 click 事件处理过程 *** 第一次 Child 组件渲染是浪费的。并且我们也不会让 React 跳过 Child 的第二次渲染因为 Parent 可能会传递不同的数据由于其自身的状态更新。 这就是为什么 React 会在组件内所有事件触发完成后再进行批量更新的原因： *** 进入 React 浏览器 click 事件处理过程 *** Child (onClick) - setState Parent (onClick) - setState *** Processing state updates *** - re-render Parent - re-render Child *** 结束 React 浏览器 click 事件处理过程 *** 组件内调用 setState 并不会立即执行重渲染。相反，React 会先触发所有的事件处理器，然后再触发一次重渲染以进行所谓的批量更新。 批量更新虽然有用但可能会让你感到惊讶如果你的代码这样写： const [count, setCounter] = useState(0); function increment() { setCounter(count + 1); } function handleClick() { increment(); increment(); increment(); } 如果我们将 count 初始值设为 0 ，上面的代码只会代表三次 setCount(1) 调用。为了解决这个问题，我们给 setState 提供了一个 “updater” 函数作为参数： const [count, setCounter] = useState(0); function increment() { setCounter(c => c + 1); } function handleClick() { increment(); increment(); increment(); } React 会将 updater 函数放入队列中，并在之后按顺序执行它们，最终 count 会被设置成 3 并作为一次重渲染的结果。 当状态逻辑变得更加复杂而不仅仅只是少数的 setState 调用时，我建议你使用 useReducer Hook 来描述你的局部状态。它就像 “updater” 的升级模式在这里你可以给每一次更新命名： const [counter, dispatch] = useReducer((state, action) => { if (action === 'increment') { return state + 1; } else { return state; } }, 0); function handleClick() { dispatch('increment'); dispatch('increment'); dispatch('increment'); } action 字段可以是任意值，尽管对象是常用的选择。 调用树 编程语言的运行时往往有调用栈 。当函数 a() 调用 b() ，b() 又调用 c() 时，在 JavaScript 引擎中会有像 [a, b, c] 这样的数据结构来“跟踪”当前的位置以及接下来要执行的代码。一旦 c 函数执行完毕，它的调用栈帧就消失了！因为它不再被需要了。我们返回到函数 b 中。当我们结束函数 a 的执行时，调用栈就被清空。 当然，React 以 JavaScript 运行当然也遵循 JavaScript 的规则。但是我们可以想象在 React 内部有自己的调用栈用来记忆我们当前正在渲染的组件，例如 [App, Page, Layout, Article /* 此刻的位置 */] 。 React 与通常意义上的编程语言进行时不同因为它针对于渲染 UI 树，这些树需要保持“活性”，这样才能使我们与其进行交互。在第一次 ReactDOM.render() 出现之前，DOM 操作并不会执行。 这也许是对隐喻的延伸，但我喜欢把 React 组件当作 “调用树” 而不是 “调用栈” 。当我们调用完 Article 组件，它的 React “调用树” 帧并没有被摧毁。我们需要将局部状态保存以便映射到宿主实例的某个地方。 这些“调用树”帧会随它们的局部状态和宿主实例一起被摧毁，但是只会在协调规则认为这是必要的时候执行。如果你曾经读过 React 源码，你就会知道这些帧其实就是 Fibers) 。 Fibers 是局部状态真正存在的地方。当状态被更新后，React 将其下面的 Fibers 标记为需要进行协调，之后便会调用这些组件。 上下文 在 React 中，我们将数据作为 props 传递给其他组件。有些时候，大多数组件需要相同的东西 — 例如，当前选中的可视主题。将它一层层地传递会变得十分麻烦。 在 React 中，我们通过 Context 解决这个问题。它就像组件的动态范围 ，能让你从顶层传递数据，并让每个子组件在底部能够读取该值，当值变化时还能够进行重新渲染： const ThemeContext = React.createContext( 'light' // 默认值作为后备 ); function DarkApp() { return ( ); } function SomeDeeplyNestedChild() { // 取决于其子组件在哪里被渲染 const theme = useContext(ThemeContext); // ... } 当 SomeDeeplyNestedChild 渲染时， useContext(ThemeContext) 会寻找树中最近的 ，并且使用它的 value 。 (事实上，React 维护了一个上下文栈当其渲染时。) 如果没有 ThemeContext.Provider 存在，useContext(ThemeContext) 调用的结果就会被调用 createContext() 时传递的默认值所取代。在上面的例子中，这个值为 'light' 。 副作用 我们在之前提到过 React 组件在渲染过程中不应该有可观察到的副作用。但是有些时候副作用确实必要的。我们也许需要进行管理 focus 状态、用 canvas 画图、订阅数据源等操作。 在 React 中，这些都可以通过声明 effect 来完成： function Example() { const [count, setCount] = useState(0); useEffect(() => { document.title = `You clicked ${count} times`; }); return ( You clicked {count} times setCount(count + 1)}> Click me ); } 如果可能，React 会推迟执行 effect 直到浏览器重新绘制屏幕。这是有好处的因为像订阅数据源这样的代码并不会影响交互时间和首次绘制时间 。 （有一个极少使用的 Hook 能够让你选择退出这种行为并进行一些同步的工作。请尽量避免使用它。） effect 不只执行一次。当组件第一次展示给用户以及之后的每次更新时它都会被执行。在 effect 中能触及当前的 props 和 state，例如上文例子中的 count 。 effect 可能需要被清理，例如订阅数据源的例子。在订阅之后将其清理，effect 能够返回一个函数： useEffect(() => { DataSource.addSubscription(handleChange); return () => DataSource.removeSubscription(handleChange); }); React 会在下次调用该 effect 之前执行这个返回的函数，当然是在组件被摧毁之前。 有些时候，在每次渲染中都重新调用 effect 是不符合实际需要的。 你可以告诉 React 如果相应的变量不会改变则跳过此次调用： useEffect(() => { document.title = `You clicked ${count} times`; }, [count]); 但是，这往往会成为过早地优化并会造成一些问题如果你不熟悉 JavaScript 中的闭包是如何工作的话。 例如，下面的这段代码是有 bug 的： useEffect(() => { DataSource.addSubscription(handleChange); return () => DataSource.removeSubscription(handleChange); }, []); 它含有 bug 因为 [] 代表着“不再重新执行这个 effect 。”但是这个 effect 中的 handleChange 是被定义在外面的。handleChange 也许会引用任何的 props 或 state ： function handleChange() { console.log(count); } 如果我们不再让这个 effect 重新调用，handleChange 始终会是第一次渲染时的版本，而其中的 count 也永远只会是 0 。 为了解决这个问题，请保证你声明了特定的依赖数组，它包含所有可以改变的东西，即使是函数也不例外： useEffect(() => { DataSource.addSubscription(handleChange); return () => DataSource.removeSubscription(handleChange); }, [handleChange]); 取决于你的代码，在每次渲染后 handleChange 都会不同因此你可能仍然会看到不必要的重订阅。 useCallback 能够帮你解决这个问题。或者，你可以直接让它重订阅。例如浏览器中的 addEventListener API 非常快，但为了在组件中避免使用它可能会带来更多的问题而不是其真正的价值。 (你能在 React 文档 中学到更多关于 useEffect 和其他 Hooks 的知识。) 自定义钩子 由于 useState 和 useEffect 是函数调用，因此我们可以将其组合成自己的 Hooks ： function MyResponsiveComponent() { const width = useWindowWidth(); // 我们自己的 Hook return ( Window width is {width} ); } function useWindowWidth() { const [width, setWidth] = useState(window.innerWidth); useEffect(() => { const handleResize = () => setWidth(window.innerWidth); window.addEventListener('resize', handleResize); return () => { window.removeEventListener('resize', handleResize); }; }); return width; } 自定义 Hooks 让不同的组件共享可重用的状态逻辑。注意状态本身是不共享的。每次调用 Hook 都只声明了其自身的独立状态。 (你能在 React 文档 中学习更多关于构建自己的 Hooks 的内容。) 静态使用顺序 你可以把 useState 想象成一个可以定义“React 状态变量”的语法。它并不是真正的语法，当然，我们仍在用 JavaScript 编写应用。但是我们将 React 作为一个运行时环境来看待，因为 React 用 JavaScript 来描绘整个 UI 树，它的特性往往更接近于语言层面。 假设 use 是语法，将其使用在组件函数顶层也就说得通了： // &#x1F609; 注意：并不是真的语法 component Example(props) { const [count, setCount] = use State(0); return ( You clicked {count} times setCount(count + 1)}> Click me ); } 当它被放在条件语句中或者组件外时又代表什么呢？ // &#x1F609; 注意：并不是真的语法 // 它是谁的...局部状态？ const [count, setCount] = use State(0); component Example() { if (condition) { // 要是 condition 是 false 时会发生什么呢？ const [count, setCount] = use State(0); } function handleClick() { // 要是离开了组件函数会发生什么？ // 这和一般的变量又有什么区别呢？ const [count, setCount] = use State(0); } } React 状态和在树中与其相关的组件紧密联系在一起。如果 use 是真正的语法当它在组件函数的顶层调用时也能说的通： // &#x1F609; 注意：并不是真的语法 component Example(props) { // 只在这里有效 const [count, setCount] = use State(0); if (condition) { // 这会是一个语法错误 const [count, setCount] = use State(0); } } 这和 import 声明只在模块顶层有用是一样的道理。 当然，use 并不是真正的语法。 （它不会带来很多好处，并且会带来很多摩擦。） 然而，React 的确期望所有的 Hooks 调用只发生在组件的顶部并且不在条件语句中。这些 Hooks 的规则能够被 linter plugin 所规范。有很多关于这种设计选择的激烈争论，但在实践中我并没有看到它让人困惑。我还写了关于为什么通常提出的替代方案不起作用的文章。 Hooks 的内部实现其实是链表 。当你调用 useState 的时候，我们将指针移到下一项。当我们退出组件的“调用树”帧时，会缓存该结果的列表直到下次渲染开始。 这篇文章简要介绍了 Hooks 内部是如何工作的。数组也许是比链表更好解释其原理的模型： // 伪代码 let hooks, i; function useState() { i++; if (hooks[i]) { // 再次渲染时 return hooks[i]; } // 第一次渲染 hooks.push(...); } // 准备渲染 i = -1; hooks = fiber.hooks || []; // 调用组件 YourComponent(); // 缓存 Hooks 的状态 fiber.hooks = hooks; (如果你对它感兴趣，真正的代码在这里 。) 这大致就是每个 useState() 如何获得正确状态的方式。就像我们之前所知道的，“匹配”对 React 来说并不是什么新的知识 — 这与协调依赖于在渲染前后元素是否匹配是同样的道理。 未提及的知识 我们已经触及到 React 运行时环境中几乎所有重要的方面。如果你读完了本篇文章，你可能已经比 90% 的开发者更了解 React ！这一点也没有错！ 当然有一些地方我并没有提及到 — 主要是因为我们对它们也不太清楚。React 目前对多道渲染并没有太好的支持，即当父组件的渲染需要子组件提供信息时。错误处理 API 目前也还没有 Hooks 的版本。这两个问题可能会被一起解决。并发模式在目前看来并不稳定，也有很多关于 Suspense 该如何适应当前版本的有趣问题。也许我会在它们要完成的时候再来讨论，并且 Suspense 已经准备好比 lazy loading 能够做的更多。 我认为 React API 的成功之处在于，即使在没有考虑过上面这些大多数主题的情况下，你也能轻松使用它并且可以走的很远。 在大多数情况下，像协调这样好的默认特性启发式地为我们做了正确的事情。在你忘记添加 key 这样的属性时，React 能够好心提醒你。 如果你是痴迷于 UI 库的书呆子，我希望这篇文章对你来说会很有趣并且是深入阐明了 React 是如何工作的。又或许你会觉得 React 太过于复杂为此你不会再去深入理解它。不管怎样，我都很乐意在 Twitter 上收到你的消息！谢谢你的阅读。 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:19:09 "},"articles/react/how-does-setstate-know-what-to-do.html":{"url":"articles/react/how-does-setstate-know-what-to-do.html","title":"[转] setState 如何知道该做什么","keywords":"","body":"setState 如何知道该做什么？ 本文转自：https://overreacted.io/zh-hans/how-does-setstate-know-what-to-do/ 当你在组件中调用setState的时候，你认为发生了些什么？ import React from 'react'; import ReactDOM from 'react-dom'; class Button extends React.Component { constructor(props) { super(props); this.state = { clicked: false }; this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState({ clicked: true }); } render() { if (this.state.clicked) { return Thanks; } return ( Click me! ); } } ReactDOM.render(, document.getElementById('container')); 当然是：React根据下一个状态{clicked：true}重新渲染组件，同时更新DOM以匹配返回的Thanks元素啊。 看起来很直白。但是等等，是 React做了这些吗？还是React DOM？ 更新DOM听起来像是React DOM的职责所在。但是我们调用的是this.setState()，而没有调用 任何来自React DOM的东西。 而且我们组件的父类React.Component也是在React本身定义的。 所以存在于React.Component 内部的setState()是如何更新DOM的呢？ 免责声明: 就像本博客里绝大多数 其他的 帖子一样， 其实你不需要知道其中的任何知识，就可以有效地使用React。 本文面向的是那些想要了解React背后原理的人。而这完全是可选的！ 我们或许会认为：React.Component类包含了DOM 更新的逻辑。 但是如果是这样的话，this.setState()又如何能在其他环境下使用呢？举个例子，React Native app中的组件也是 继承自React.Component。他们依然可以像我们在上面做的那样调用this.setState()，而且React Native 渲染的是安卓和iOS原生的 界面而不是DOM。 你或许对React Test Renderer 或是 Shallow Renderer很熟悉。这些测试策略能让你 正常渲染组件， 也可以在组件内部调用this.setState()。但是这两个渲染器并不与DOM相关。 如果你曾使用过一些渲染器像React ART，你也许也知道在一个页面中我们是可以使用多个渲染器的。（举个例子，ART 组件在React DOM树的内部起作用。）这使得全局标志或变量无法维持。 因此，React.Component以某种未知的方式将处理 状态（state）更新的任务委托给了特定平台的代码。在我们理解这些是如何发生的之前，让我们深挖一下包（packages）是如何分离的以及为什么这样分离。 有一个很常见的误解就是React“引擎”是存在于react包里面的。 然而事实并非如此。 实际上从React 0.14我们将代码拆分成多个包以来，react包故意 只暴露一些定义组件的API。绝大多数React的 实现都存在于“渲染器（renderers）”中。 react-dom、react-dom/server、 react-native、 react-test-renderer、 react-art都是常见的渲染器（当然你也可以创建属于你的渲染器）。 这就是为什么不管你的目标平台是什么，react包都是可用的。从react包中导出的一切，比如React.Component、React.createElement、 React.Children 和（最终的）Hooks，都是独立于目标平台的。无论你是运行React DOM，还是 React DOM Server,或是 React Native，你的组件都可以使用同样的方式导入和使用。 相比之下，渲染器包 暴露的都是特定平台的API ，比如说：ReactDOM.render()，可以让你将React层次结构（hierarchy）挂载进一个DOM节点。每一种渲染器都提供了类似的API。理想状况下，绝大多数组件都不应该从渲染器中导入任何东西。只有这样，组件才会更加灵活。 和大多数人现在想的一样，React “引擎”就是存在于各个渲染器的内部。很多渲染器包含一份 同样代码的复制 —— 我们称为“协调器”(“reconciler”)。构建步骤(build step)将协调器代码和渲染器代码 平滑地整合成一个高度优化的捆绑包（bundle）以获得更高的性能。（代码复制通常来说不利于控制捆绑包的大小，但是 绝大多数React用户同一时间只会选用一个渲染器，比如说react-dom。） 这里要注意的是： react包仅仅是让你使用 React 的特性，但是它完全不知道这些特性是如何实现的。而渲染器包(react-dom、react-native等)提供了React特性 的实现以及平台特定的逻辑。这其中的有些代码是共享的(“协调 器”)，但是这就涉及到各个渲染器的实现细节了。 现在我们知道为什么当我们想使用新特性时，react 和 react-dom都需要被更新。举个例子，当React 16.3添加了Context API，React.createContext()API会被React包暴露出来。 但是React.createContext() 其实并没有实现 context。因为在React DOM 和 React DOM Server 中同样一个 API 应当有不同的实现。所以createContext()只返回了一些普通对象： // 简化版代码 function createContext(defaultValue) { let context = { _currentValue: defaultValue, Provider: null, Consumer: null }; context.Provider = { $$typeof: Symbol.for('react.provider'), _context: context }; context.Consumer = { $$typeof: Symbol.for('react.context'), _context: context, }; return context; } 当你在代码中使用 或 的时候， 是渲染器 决定如何处理这些接口。React DOM也许用某种方式追踪context的值，但是React DOM Server用的可能是另一种不同的方式。 所以，如果你将react升级到了16.3+，但是不更新react-dom，那么你就使用了一个尚不知道 Provider 和 Consumer类型的渲染器。这就是为什么一个老版本的react-dom会 报错说这些类型是无效的。 同样的警告也会出现在React Native中。然而不同于React DOM的是， 一个React新版本的发布并不立即“强制”发布新的 React Native 版本。他们具有独立的发布日程。 每隔几周，更新后的渲染器代码就会单独同步到React Native仓库。这就是相比 React DOM，React Native 特性可用时间不同的原因。 好吧，所以现在我们知道了react包并不包含任何有趣的东西， 除此之外，具体的实现也 是存在于react-dom，react-native之类的渲染器中。但是这并没有回答我们的问题。React.Component中的setState()如何与正确的渲染器“对话”？ 答案是：每个渲染器都在已创建的类上设置了一个特殊的字段。这个字段叫做updater。这并不是你要设置的的东西——而是，React DOM、React DOM Server 或 React Native在创建完你的 类的实例之后会立即设置的东西： // React DOM 内部 const inst = new YourComponent(); inst.props = props; inst.updater = ReactDOMUpdater; // React DOM Server 内部 const inst = new YourComponent(); inst.props = props; inst.updater = ReactDOMServerUpdater; // React Native 内部 const inst = new YourComponent(); inst.props = props; inst.updater = ReactNativeUpdater; 查看 React.Component中setState的实现， setState所做的一切就是委托渲染器创建这个组件的实例： // 适当简化的代码 setState(partialState, callback) { // 使用`updater`字段回应渲染器！ this.updater.enqueueSetState(this, partialState, callback); } React DOM Server 也许想 忽略一个状态更新 并且警告你，而React DOM 与 React Native却想要让他们协调器（reconciler）的副本处理它。 这就是this.setState()尽管定义在React包中，却能够 更新DOM的原因。它 读取由React DOM设置的this.updater`，让React DOM安排并处理更新。 现在关于类的部分我们已经知道了，那关于Hooks的呢？ 当人们第一次看见Hooks proposal API， 他们 可能经常会想： useState是怎么 “知道要做什么”的？然后假设它比那些 包含this.setState()的React.Component类更“神奇”。 但是正如我们今天所看到的，基类中setState()的执行一直以来都是一种错觉。它除了将调用转发给当前的渲染器外，什么也没做 。useState Hook也是做了同样的事情。 Hooks使用了一个“dispatcher”对象，代替了updater字段。当你调用React.useState() 、React.useEffect()、 或者其他内置的Hook时，这些调用被转发给了当前的dispatcher。 // React内部(适当简化) const React = { // 真实属性隐藏的比较深，看你能不能找到它！ __currentDispatcher: null, useState(initialState) { return React.__currentDispatcher.useState(initialState); }, useEffect(initialState) { return React.__currentDispatcher.useEffect(initialState); }, // ... }; 各个渲染器会在渲染你的组件之前设置dispatcher： // React DOM 内部 const prevDispatcher = React.__currentDispatcher; React.__currentDispatcher = ReactDOMDispatcher; let result; try { result = YourComponent(props); } finally { // 恢复原状 React.__currentDispatcher = prevDispatcher; } 举个例子， React DOM Server的实现是在 这里，还有就是React DOM 和 React Native共享的协调器的实现在这里。 这就是为什么像react-dom这样的渲染器需要 访问那个你调用Hooks的react包。否则你的组件将不会 “看见”dispatcher！如果在一个组件树中存在React的多个副本， 也许并不会这样。但是，这总是导致了一些模糊的错误，因此Hooks会强迫你在出现问题之前解决包的重复问题。 在高级工具用例中，你可以 在技术上覆盖dispatcher，尽管我们不鼓励这种操作。（对于__currentDispatcher这个名字我撒谎了，但是你可以在React仓库中找到真实的名字。） 比如说， React DevTools将会使用 一个专门定制的dispatcher通过捕获JavaScript堆栈跟踪来观察Hooks树。请勿模仿。 这也意味着Hooks 本质上并没有与React绑定在一起。如果未来有更多的库想要重用同样的原生的Hooks, 理论上来说dispatcher可以 移动到一个分离的包中，然后暴露成一个一等（first-class）的API，然后给它起一个不那么“吓人 ”的名字。但是在实践中，我们会尽量 避免过早抽象，直到需要它为止。 updater字段和__currentDispatcher对象都是称为依赖注入的通用编程原则的形式。在这两种情况下，渲染器将诸如setState之类的功能的实现“注入”到通用的React包中，以使组件更具声明性。 使用React时，你无需考虑这其中的原理。我们希望React用户花更多时间考虑他们的应用程序代码，而不是像依赖注入这样的抽象概念。但是如果你想知道this.setState()或useState()是如何知道该做什么的，我希望这篇文章会有所帮助。 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 16:58:50 "},"articles/react/why-do-we-write-super-props.html":{"url":"articles/react/why-do-we-write-super-props.html","title":"[转] 为什么我们要写 super(props)","keywords":"","body":"为什么我们要写 super(props) ？ 本文转自：https://overreacted.io/zh-hans/why-do-we-write-super-props/ 首先，在这一生中，super(props) 出现在我代码里的次数比我知道的还要多： class Checkbox extends React.Component { constructor(props) { super(props); this.state = { isOn: true }; } // ... } 当然了，我们可以通过 class fields proposal 来省略这个声明： class Checkbox extends React.Component { state = { isOn: true }; // ... } 早在 2015 年 React 0.13 已经计划支持 。在当时，声明 constructor 和调用 super(props) 一直被视作暂时的解决方案，直到有合适的类字段声明形式。 但在此之前，我们先回到 ES2015 风格的代码： class Checkbox extends React.Component { constructor(props) { super(props); this.state = { isOn: true }; } // ... } 为什么我们要调用 super，我们可以不这么做吗？那么在我们调用它时不传入 props，又会发生什么呢？会有其他的缺省参数吗？接来下我们就解开这一系列谜题。 在 JavaScript 中，super 指的是父类（即超类）的构造函数。（在我们的例子中，它指向了 React.Component 的实现。） 值得注意的是，在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的。JavaScript 不允许这个行为。 class Checkbox extends React.Component { constructor(props) { // &#x1F534; 还不能使用 `this` super(props); // ✅ 现在可以了 this.state = { isOn: true }; } // ... } JavaScript 有足够合理的动机来强制你在接触 this 之前执行父类构造函数。考虑考虑一些类层次结构的东西： class Person { constructor(name) { this.name = name; } } class PolitePerson extends Person { constructor(name) { this.greetColleagues(); // &#x1F534; 这是禁止的，往后见原因 super(name); } greetColleagues() { alert('Good morning folks!'); } } 试想一下，在调用 super 之前使用 this 不被禁止的情况下，一个月后，我们可能在 greetColleagues 打印的消息中使用了 person 的 name 属性： greetColleagues() { alert('Good morning folks!'); alert('My name is ' + this.name + ', nice to meet you!'); } 但是我们并未想起 this.greetColleagues 在 super() 给 this.name 赋值前就已经执行。this.name 此时甚至尚未定义。可以看到，这样的代码难以往下推敲。 为了避免落入这个陷阱，JavaScript 强制你在使用 this 之前先行调用 super。让父类来完成这件事情！： constructor(props) { super(props); // ✅ 能使用 `this` 了 this.state = { isOn: true }; } 这里留下了另一个问题：为什么要传入 props ？ 你或许会想到，为了让 React.Component 构造函数能够初始化 this.props，将 props 传入 super 是必须的： // React 內部 class Component { constructor(props) { this.props = props; // ... } } 这几乎就是真相了 — 确然，它是 这样做 的。 但有些扑朔迷离的是，即便你调用 super() 的时候没有传入 props，你依然能够在 render 函数或其他方法中访问到 this.props。（如果你质疑这个机制，尝试一下即可） 那么这是怎么做到的呢？事实证明，React 在调用构造函数后也立即将 props 赋值到了实例上：** // React 内部 const instance = new YourComponent(props); instance.props = props; 因此即便你忘记了将 props 传给 super()，React 也仍然会在之后将它定义到实例上。这么做是有原因的。 当 React 增加了对类的支持时，不仅仅是为了服务于 ES6。其目标是尽可能广泛地支持类抽象。当时我们 不清楚 ClojureScript，CoffeeScript，ES6，Fable，Scala.js，TypeScript 等解決方案是如何成功的实践组件定义的。因而 React 刻意地没有显式要求调用 super() —— 即便 ES6 自身就包含这个机制。 这意味着你能够用 super() 代替 super(props) 吗？ 最好不要，毕竟这样写在逻辑上并不明确确然，React 会在构造函数执行完毕之后给 this.props 赋值。但如此为之会使得 this.props 在 super 调用一直到构造函数结束期间值为 undefined。 // React 內部 class Component { constructor(props) { this.props = props; // ... } } // 你的程式碼內部 class Button extends React.Component { constructor(props) { super(); // &#x1F62C; 我们忘了传入 props console.log(props); // ✅ {} console.log(this.props); // &#x1F62C; 未定义 } // ... } 如果在构造函数中调用了其他的内部方法，那么一旦出错这会使得调试过程阻力更大。这就是我建议开发者一定执行 super(props) 的原因，即使理论上这并非必要： class Button extends React.Component { constructor(props) { super(props); // ✅ 传入 props console.log(props); // ✅ {} console.log(this.props); // ✅ {} } // ... } 确保了 this.props 在构造函数执行完毕之前已被赋值。 最后，还有一点是 React 爱好者长期以来的好奇之处。 你会发现当你在类中使用 Context API （无论是旧版的 contextTypes 或是在 React 16.6 更新的新版 contextTypes）的时候，context 是作为第二个参数传入构造函数的。 那么为什么我们不能转而写成 super(props, context) 呢？我们当然可以，但 context 的使用频率较低，因而并没有掘这个坑。 class fields proposal 出台后，这些坑大部分都会自然地消失在没有显示的定义构造函数的情况下，以上的属性都会被自动地初始化。这使得像 state = {} 这类表达式能够在需要的情况下引用 this.props 和 this.context 的内容。 然而，有了 Hooks 以后，我们几乎就不需要 super 和 this 了。但那就是另一个下午的茶点了。 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:54:10 "},"articles/react/how-does-react-tell-a-class-from-a-function.html":{"url":"articles/react/how-does-react-tell-a-class-from-a-function.html","title":"[转] React 如何区分 Class 和 Function","keywords":"","body":"React 如何区分 Class 和 Function？ 本文转自：https://overreacted.io/zh-hans/how-does-react-tell-a-class-from-a-function/ 让我们来看一下这个以函数形式定义的 Greeting 组件： function Greeting() { return Hello; } React 也支持将他定义成一个类： class Greeting extends React.Component { render() { return Hello; } } （直到最近，这是使用 state 特性的唯一方式） 当你要渲染一个 组件时，你并不需要关心它是如何定义的： // 是类还是函数 —— 无所谓 但 React 本身 在意其中的差别！ 如果 Greeting 是一个函数，React 需要调用它。 // 你的代码 function Greeting() { return Hello; } // React 内部 const result = Greeting(props); // Hello 但如果 Greeting 是一个类，React 需要先用 new 操作符将其实例化，然后 调用刚才生成实例的 render 方法： // 你的代码 class Greeting extends React.Component { render() { return Hello; } } // React 内部 const instance = new Greeting(props); // Greeting {} const result = instance.render(); // Hello 无论哪种情况 React 的目标都是去获取渲染后的节点（在这个案例中，Hello）。但具体的步骤取决于 Greeting 是如何定义的。 所以 React 是怎么知道某样东西是 class 还是 function 的呢？ 就像我上一篇博客中提到的，你并不需要知道这个才能高效使用 React。 我多年来都不知道这个。请不要把这变成一道面试题。事实上，这篇博客更多的是关于 JavaScript 而不是 React。 这篇博客是写给那些对 React 具体是 如何 工作的表示好奇的读者的。你是那样的人吗？那我们一起深入探讨一下吧。 这将是一段漫长的旅程，系好安全带。这篇文章并没有多少关于 React 本身的信息，但我们会涉及到 new、this、class、箭头函数、prototype、proto、instanceof 等方面，以及这些东西是如何在 JavaScript 中一起工作的。幸运的是，你并不需要在使用 React 时一直想着这些，除非你正在实现 React… （如果你真的很想知道答案，直接翻到最下面。） 首先，我们需要理解为什么把函数和类分开处理很重要。注意看我们是怎么使用 new 操作符来调用一个类的： // 如果 Greeting 是一个函数 const result = Greeting(props); // Hello // 如果 Greeting 是一个类 const instance = new Greeting(props); // Greeting {} const result = instance.render(); // Hello 我们来简单看一下 new 在 JavaScript 是干什么的。 在过去，JavaScript 还没有类。但是，你可以使用普通函数来模拟。具体来讲，只要在函数调用前加上 new 操作符，你就可以把任何函数当做一个类的构造函数来用： // 只是一个函数 function Person(name) { this.name = name; } var fred = new Person('Fred'); // ✅ Person {name: 'Fred'} var george = Person('George'); // &#x1F534; 没用的 现在你依然可以这样写！在 DevTools 里试试吧。 如果你调用 Person('Fred') 时没有加 new，其中的 this 会指向某个全局且无用的东西（比如，window 或者 undefined），因此我们的代码会崩溃，或者做一些像设置 window.name 之类的傻事。 通过在调用前增加 new，我们说：「嘿 JavaScript，我知道 Person 只是个函数，但让我们假装它是个构造函数吧。创建一个 {} 对象并把 Person 中的 this 指向那个对象，以便我可以通过类似 this.name 的形式去设置一些东西，然后把这个对象返回给我。」 这就是 new 操作符所做的事。 var fred = new Person('Fred'); // 和 `Person` 中的 `this` 等效的对象 new 操作符同时也把我们放在 Person.prototype 上的东西放到了 fred 对象上： function Person(name) { this.name = name; } Person.prototype.sayHi = function() { alert('Hi, I am ' + this.name);} var fred = new Person('Fred'); fred.sayHi(); 这就是在 JavaScript 直接支持类之前，人们模拟类的方式。 new 在 JavaScript 中已经存在了好久了，然而类还只是最近的事，它的出现让我们能够重构我们前面的代码以使它更符合我们的本意： class Person { constructor(name) { this.name = name; } sayHi() { alert('Hi, I am ' + this.name); } } let fred = new Person('Fred'); fred.sayHi(); 捕捉开发者的本意是语言和 API 设计中非常重要的一点。 如果你写了一个函数，JavaScript 没办法判断它应该像 alert() 一样被调用，还是应该被视作像 new Person() 一样的构造函数。忘记给像 Person 这样的函数指定 new 会导致令人费解的行为。 类语法允许我们说：「这不仅仅是个函数 —— 这是个类并且它有构造函数」。 如果你在调用它时忘了加 new，JavaScript 会报错： let fred = new Person('Fred'); // ✅ 如果 Person 是个函数：有效 // ✅ 如果 Person 是个类：依然有效 let george = Person('George'); // 我们忘记使用 `new` // &#x1F633; 如果 Person 是个长得像构造函数的方法：令人困惑的行为 // &#x1F534; 如果 Person 是个类：立即失败 这可以帮助我们在早期捕捉错误，而不会遇到类似 this.name 被当成 window.name 对待而不是 george.name 的隐晦错误。 然而，这意味着 React 需要在调用所有类之前加上 new，而不能把它直接当做一个常规的函数去调用，因为 JavaScript 会把它当做一个错误对待！ class Counter extends React.Component { render() { return Hello; } } // &#x1F534; React 不能简单这么做： const instance = Counter(props); 这意味着麻烦。 在我们看到 React 如何处理这个问题之前，很重要的一点就是要记得大部分 React 的用户会使用 Babel 等编译器来编译类等现代化的特性以便能在老旧的浏览器上运行。因此我们需要在我们的设计中考虑编译器。 在 Babel 的早期版本中，类不加 new 也可以被调用。但这个问题已经被修复了 —— 通过生成额外的代码的方式。 function Person(name) { // 稍微简化了一下 Babel 的输出： if (!(this instanceof Person)) { throw new TypeError(\"Cannot call a class as a function\"); } // Our code: this.name = name; } new Person('Fred'); // ✅ OK Person('George'); // &#x1F534; 无法把类当做函数来调用 你或许已经在你构建出来的包中见过类似的代码，这就是那些 _classCallCheck 函数做的事。（你可以通过启用「loose mode」来关闭检查以减小构建包的尺寸，但这或许会使你最终转向真正的原生类时变得复杂） 至此，你应该已经大致理解了调用时加不加 new 的差别： new Person() Person() class ✅ this 是一个 Person 实例 &#x1F534; TypeError function ✅ this 是一个 Person 实例 &#x1F633; this 是 window 或 undefined 这就是 React 正确调用你的组件很重要的原因。如果你的组件被定义为一个类，React 需要使用 new 来调用它。 所以 React 能检查出某样东西是否是类吗？ 没那么容易！即便我们能够在 JavaScript 中区分类和函数，面对被 Babel 等工具处理过的类这还是没用。对浏览器而言，它们只是不同的函数。这是 React 的不幸。 好，那 React 可以直接在每次调用时都加上 new 吗？很遗憾，这种方法并不总是有用。 对于常规函数，用 new 调用会给它们一个 this 作为对象实例。对于用作构造函数的函数（比如我们前面提到的 Person）是可取的，但对函数组件这或许就比较令人困惑了： function Greeting() { // 我们并不期望 `this` 在这里表示任何类型的实例 return Hello; } 这暂且还能忍，还有两个其他理由会扼杀这个想法。 关于为什么总是使用 new 是没用的的第一个理由是，对于原生的箭头函数（不是那些被 Babel 编译过的），用 new 调用会抛出一个错误： const Greeting = () => Hello; new Greeting(); // &#x1F534; Greeting 不是一个构造函数 这个行为是遵循箭头函数的设计而刻意为之的。箭头函数的一个附带作用是它没有自己的 this 值 —— this 解析自离得最近的常规函数： class Friends extends React.Component { render() { const friends = this.props.friends; return friends.map(friend => ); } } OK，所以箭头函数没有自己的 this。但这意味着它作为构造函数是完全无用的！ const Person = (name) => { // &#x1F534; 这么写是没有意义的！ this.name = name; } 因此，JavaScript 不允许用 new 调用箭头函数。如果你这么做，你或许已经犯了错，最好早点告诉你。这和 JavaScript 不让你不加 new 去调用一个类是类似的。 这样很不错，但这也让我们的计划受阻。React 不能简单对所有东西都使用 new，因为会破坏箭头函数！我们可以利用箭头函数没有 prototype 的特点来检测箭头函数，不对它们使用 new： (() => {}).prototype // undefined (function() {}).prototype // {constructor: f} 但这对于被 Babel 编译过的函数是没用的。这或许没什么大不了，但还有另一个原因使得这条路不会有结果。 另一个我们不能总是使用 new 的原因是它会妨碍 React 支持返回字符串或其它原始类型的组件。 function Greeting() { return 'Hello'; } Greeting(); // ✅ 'Hello' new Greeting(); // &#x1F633; Greeting {} 这，再一次，和new 操作符的怪异设计有关。如我们之前所看到的，new 告诉 JavaScript 引擎去创建一个对象，让这个对象成为函数内部的 this，然后把这个对象作为 new 的结果给我们。 然而，JavaScript 也允许一个使用 new 调用的函数返回另一个对象以 覆盖 new 的返回值。或许，这在我们利用诸如「对象池模式」来对组件进行复用时是被认为有用的： // 创建了一个懒变量 zeroVector = null; function Vector(x, y) { if (x === 0 && y === 0) { if (zeroVector !== null) { // 复用同一个实例 return zeroVector; } zeroVector = this; } this.x = x; this.y = y; } var a = new Vector(1, 1); var b = new Vector(0, 0); var c = new Vector(0, 0); // &#x1F632; b === c 然而，如果一个函数的返回值不是一个对象，它会被 new 完全忽略。如果你返回了一个字符串或数字，就好像完全没有 return 一样。 function Answer() { return 42; } Answer(); // ✅ 42 new Answer(); // &#x1F633; Answer {} 当使用 new 调用函数时，是没办法读取原始类型（例如一个数字或字符串）的返回值的。因此如果 React 总是使用 new，就没办法增加对返回字符串的组件的支持！ 这是不可接受的，因此我们必须妥协。 至此我们学到了什么？React 在调用类（包括 Babel 输出的）时需要用 new，但在调用常规函数或箭头函数时（包括 Babel 输出的）不需要用 new，并且没有可靠的方法来区分这些情况。 如果我们没法解决一个笼统的问题，我们能解决一个具体的吗？ 当你把一个组件定义为类，你很可能会想要扩展 React.Component 以便获取内置的方法，比如 this.setState()。 与其试图检测所有的类，我们能否只检测 React.Component 的后代呢？ 剧透：React 就是这么干的。 或许，检查 Greeting 是否是一个 React 组件类的最符合语言习惯的方式是测试 Greeting.prototype instanceof React.Component： class A {} class B extends A {} console.log(B.prototype instanceof A); // true 我知道你在想什么，刚才发生了什么？！为了回答这个问题，我们需要理解 JavaScript 原型。 你或许对「原型链」很熟悉。JavaScript 中的每一个对象都有一个「原型」。当我们写 fred.sayHi() 但 fred 对象没有 sayHi 属性，我们尝试到 fred 的原型上去找 sayHi 属性。要是我们在这儿找不到，就去找原型链的下一个原型 —— fred 的原型的原型，以此类推。 费解的是，一个类或函数的 prototype 属性 并不 指向那个值的原型。我没开玩笑。 function Person() {} console.log(Person.prototype); // &#x1F92A; 不是 Person 的原型 console.log(Person.__proto__); // &#x1F633; Person 的原型 因此「原型链」更像是 __proto__.__proto__.__proto__ 而不是 prototype.prototype.prototype，我花了好几年才搞懂这一点。 那么函数和类的 prototype 属性又是什么？是用 new 调用那个类或函数生成的所有对象的 proto！ function Person(name) { this.name = name; } Person.prototype.sayHi = function() { alert('Hi, I am ' + this.name); } var fred = new Person('Fred'); // 设置 `fred.__proto__` 为 `Person.prototype` 那个 __proto__ 链才是 JavaScript 用来查找属性的： fred.sayHi(); // 1. fred 有 sayHi 属性吗？不。 // 2. fred.__proto__ 有 sayHi 属性吗？是的，调用它！ fred.toString(); // 1. fred 有 toString 属性吗？不。 // 2. fred.__proto__ 有 toString 属性吗？不。 // 3. fred.__proto__.__proto__ 有 toString 属性吗？是的，调用它！ 在实战中，你应该几乎永远不需要直接在代码里动到 __proto__ ，除非你在调试和原型链相关的问题。如果你想让某样东西在 fred.__proto__ 上可用，你应该把它放在 Person.prototype，至少它最初是这么设计的。 __proto__ 属性甚至一开始就不应该被浏览器暴露出来，因为原型链应该被视为一个内部概念，然而某些浏览器增加了 __proto__ 并最终勉强被标准化（但已被废弃并推荐使用 Object.getPrototypeOf()）。 然而一个名叫「原型」的属性却给不了我一个值的「原型」这一点还是很让我困惑（例如，fred.prototype 是未定义的，因为 fred 不是一个函数）。个人观点，我觉得这是即便有经验的开发者也容易误解 JavaScript 原型链的最大原因。 这篇博客很长，是吧？已经到 80% 了，坚持住。 我们知道当说 obj.foo 的时候，JavaScript 事实上会沿着 obj, obj.__proto__, obj.__proto__.__proto__ 等等一路寻找 foo。 在使用类时，你并非直接面对这一机制，但 extends 的原理依然是基于这项老旧但有效的原型链机制。这也是的我们的 React 类实例能够访问如 setState 这样方法的原因： class Greeting extends React.Component { render() { return Hello; } } let c = new Greeting(); console.log(c.__proto__); // Greeting.prototype console.log(c.__proto__.__proto__); // React.Component.prototype console.log(c.__proto__.__proto__.__proto__); // Object.prototype c.render(); // 在 c.__proto__ (Greeting.prototype) 上找到 c.setState(); // 在 c.__proto__.__proto__ (React.Component.prototype) 上找到 c.toString(); // 在 c.__proto__.__proto__.__proto__ (Object.prototype) 上找到 换句话说，当你在使用类的时候，实例的 proto 链「镜像」了类的层级结构： // `extends` 链 Greeting → React.Component → Object (间接的) // `__proto__` 链 new Greeting() → Greeting.prototype → React.Component.prototype → Object.prototype 2 条链。 既然 __proto__ 链镜像了类的层级结构，我们可以检查一个 Greeting 是否扩展了 React.Component，我们从 Greeting.prototype 开始，一路沿着 __proto__ 链： // `__proto__` chain new Greeting() → Greeting.prototype // &#x1F575;️ 我们从这儿开始 → React.Component.prototype // ✅ 找到了！ → Object.prototype 方便的是，x instanceof Y 做的就是这类搜索。它沿着 x.__proto__ 链寻找 Y.prototype 是否在那儿。 通常，这被用来判断某样东西是否是一个类的实例： let greeting = new Greeting(); console.log(greeting instanceof Greeting); // true // greeting (我们从这儿开始) // .__proto__ → Greeting.prototype (✅ 找到了！) // .__proto__ → React.Component.prototype // .__proto__ → Object.prototype console.log(greeting instanceof React.Component); // true // greeting (我们从这儿开始) // .__proto__ → Greeting.prototype // .__proto__ → React.Component.prototype (✅ 找到了！) // .__proto__ → Object.prototype console.log(greeting instanceof Object); // true // greeting (我们从这儿开始) // .__proto__ → Greeting.prototype // .__proto__ → React.Component.prototype // .__proto__ → Object.prototype (✅ 找到了！) console.log(greeting instanceof Banana); // false // greeting (我们从这儿开始) // .__proto__ → Greeting.prototype // .__proto__ → React.Component.prototype // .__proto__ → Object.prototype (&#x1F645;‍ 没找到！) 但这用来判断一个类是否扩展了另一个类还是有效的： console.log(Greeting.prototype instanceof React.Component); // greeting // .__proto__ → Greeting.prototype ( 我们从这儿开始) // .__proto__ → React.Component.prototype (✅ 找到了！) // .__proto__ → Object.prototype 这种检查方式就是我们判断某样东西是一个 React 组件类还是一个常规函数的方式。 然而 React 并不是这么做的。 &#x1F633; 关于 instanceof 解决方案有一点附加说明，当页面上有多个 React 副本，并且我们要检查的组件继承自 另一个 React 副本的 React.Component 时，这种方法是无效的。在一个项目里混合多个 React 副本是不好的，原因有很多，但站在历史角度来看，我们试图尽可能避免问题。（有了 Hooks，我们或许得强制避免重复。） 另一点启发可以是去检查原型链上的 render 方法。然而，当时还不确定组件的 API 会如何演化。每一次检查都有成本，所以我们不想再多加了。如果 render 被定义为一个实例方法，例如使用类属性语法，这个方法也会失效。 因此, React 为基类增加了一个特别的标记。React 检查是否有这个标记，以此知道某样东西是否是一个 React 组件类。 最初这个标记是在 React.Component 这个基类自己身上： // React 内部 class Component {} Component.isReactClass = {}; // 我们可以像这样检查它 class Greeting extends Component {} console.log(Greeting.isReactClass); // ✅ 是的 然而，有些我们希望作为目标的类实现并没有复制静态属性（或设置非标准的 __proto__），标记也因此丢失。 这也是为什么 React 把这个标记移动到了 React.Component.prototype： // React 内部 class Component {} Component.prototype.isReactComponent = {}; // 我们可以像这样检查它 class Greeting extends Component {} console.log(Greeting.prototype.isReactComponent); // ✅ 是的 说真的这就是全部了。 你或许奇怪为什么是一个对象而不是一个布尔值。实战中这并不重要，但早期版本的 Jest（在 Jest 商品化之前）是默认开始自动模拟功能的，生成的模拟数据省略掉了原始类型属性，破坏了检查。谢了，Jest。 一直到今天，React 都在用 isReactComponent 进行检查。 如果你不扩展 React.Component，React 不会在原型上找到 isReactComponent，因此就不会把组件当做类处理。现在你知道为什么解决 Cannot call a class as a function 错误的得票数最高的答案是增加 extends React.Component。最后，我们还增加了一项警告，当 prototype.render 存在但 prototype.isReactComponent 不存在时会发出警告。 你或许会觉得这个故事有一点「标题党」。 实际的解决方案其实真的很简单，但我花了大量的篇幅在转折上来解释为什么 React 最终选择了这套方案，以及还有哪些候选方案。 以我的经验来看，设计一个库的 API 也经常会遇到这种情况。为了一个 API 能够简单易用，你经常需要考虑语义化（可能的话，为多种语言考虑，包括未来的发展方向）、运行时性能、有或没有编译时步骤的工程效能、生态的状态以及打包方案、早期的警告，以及很多其它问题。最终的结果未必总是最优雅的，但必须要是可用的。 如果最终的 API 成功的话，它的用户 永远不必思考这一过程。他们只需要专心创建应用就好了。 但如果你同时也很好奇…知道它是怎么工作的也是极好的。 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 16:40:44 "},"articles/nodejs/":{"url":"articles/nodejs/","title":"nodejs","keywords":"","body":"nodejs Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/nodejs/koa2middleware.html":{"url":"articles/nodejs/koa2middleware.html","title":"koa2 的中间件","keywords":"","body":"Koa2 中的 Middleware 本文主要讲述 Koa2 中 Middleware ( 中间件 ) 的实现原理。 Middleware 是 Koa 中的而一个比较重要的核心概念，中间件就是类似于一个过滤器一样的东西，是在客户端和应用程序之间处理请求和响应的方法，中间件的执行顺序就像一个洋葱，也可以理解为 V 型，下图应该很常见。 下面通过一些代码展示一下这个洋葱圈的过程。 function a(next) { console.log(1) next() console.log(2) } function b(next) { console.log(3) next() console.log(4) } function c(next) { console.log(5) next() console.log(6) } 如上三个函数，这里我们把他们当成是中间件，先不看其中的 next 的话，依次调用这三个中间件，最后控制台输出的结果应该是： // 方法 a 中 第一段 1 // 方法 a 中 第二段 2 // 方法 b 中 第一段 3 // 方法 b 中 第二段 4 // 方法 c 中 第一段 5 // 方法 c 中 第二段 6 我们反过来将 next 加进去，再按照 Middleware 的方法来执行，最后的结果就会变成： // 方法 a 中 第一段 1 // 方法 b 中 第一段 3 // 方法 c 中 第一段 5 // 方法 c 中 第二段 6 // 方法 b 中 第二段 4 // 方法 a 中 第二段 2 就好像函数执行到 next 的时候就停住了，然后跳到下一个方法执行了，最后都执行完以后，再返回来执行了每个方法的后半段，我们来看一下源码。 function compose(middleware) { return function(context, next) { // last called middleware # let index = -1 return dispatch(0) function dispatch(i) { if (i 我们假设所有的中间件都不存在异步操作，于是把 promise 都去掉，转换成同步的方式。 function compose(middleware) { dispatch(0) function dispatch(i) { var fn = middleware[i] if (!fn) return fn(function() { return dispatch(i + 1) }) } } compose([a, b, c]) 这样就清爽多了，结合这段代码，我们再去看前面的 a，b，c 三个中间件，通过这个 compose，我们可以理解为，当程序执行到 next() 的时候，检查是否有下一段需要执行的代码，这样我们可以理解为，将这三个函数合成了一个函数 function abc() { // 函数 a 的第一段 console.log(1) // next(); // 这里遇到了 next() ，执行下一个函数 // 函数 b 的第一段 console.log(3) // next(); // 这里遇到了 next() ，执行下一个函数 // 函数 c 的第一段 console.log(5) // next(); // 这里遇到了 next() ，但后面没有要执行的函数了 // 函数 c 的第二段 console.log(6) // 函数 b 的第二段 console.log(4) // 函数 a 的第二段 console.log(2) } Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/mp/":{"url":"articles/mp/","title":"微信小程序相关","keywords":"","body":"微信小程序 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/mp/scenecode.html":{"url":"articles/mp/scenecode.html","title":"跳回 APP 场景值获取","keywords":"","body":"跳回 APP 场景值获取 需求 小程序直接访问时，场景值为 1001，不显示跳回 APP 按钮 小程序通过 APP 分享卡片打开时，场景值为 1036 ，显示跳回 APP 按钮 问题 根据文档中所说，onShow 的回调参数中会带有当前场景值，结果发现 Page 的 onShow 没有回调参数 在 Page 内使用 wx.getLaunchOptionsSync 获取到的场景值不会改变，如果第一次进入小程序时，场景值为 1036，那么后面获取到的场景值都为 1036，导致即使从微信内分享的小程序卡片打开，也同样被认为是从 APP 分享过来的 在 Page 中添加 onAppShow 事件，回调参数中的场景值为正确场景值，然而执行 setData 后，数据更新，但是视图不刷新，已排除 this 指向错误的问题 解决办法 文档描述有误，onShow 只有在 app.js 内，也就是小程序的 App 下，才会有回调参数，此时的回调参数为正确的回调参数，将该参数设置在 App 的全局变量中，然后在各 Page 的 onShow 中，通过 getApp() 来获取场景值并进行 setData 操作，数据更新，视图更新 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/mp/tabbar.html":{"url":"articles/mp/tabbar.html","title":"自定义 tabbar 解决方案","keywords":"","body":"自定义tabbar解决方案 背景 用于微信小程序自定义tabbar开发，以解决原生tabbar样式无法高度定制化的情况 需求 使用 wx.switchTab 方式进行跳转 解决网上常见的解决方案中闪屏的情况（使用wx.navigateTo进行跳转） 可自定义样式 实现方案及思路 方案A 实现方式：使用单页面的方式，通过底部的tabbar点击来控制各个视图隐藏与显示的方式来实现实施时遇到的问题：A页面需要小程序原生的下拉刷新功能，B页面不需要下拉刷新功能，由于小程序单独页面的下拉刷新功能需写死在 page 的 json 文件里，无法通过设置动态开关，导致该需求无法很好的实现，后想到了一个弥补措施，即开启页面的下拉刷新功能，在可以下拉刷新的A页面，将原生加载区域的三个点的样式动态设置为与背景颜色相反的颜色，下拉后去请求数据，在不需要下拉刷新功能的B页面，动态修改三个点的样式为与背景相同的颜色，下拉后直接执行下拉的 stop 方法，这样从视觉上看，是没有做下拉刷新的操作了，从体验上来说，还是和下拉刷新时一样，会有一下停顿，对用户体验来说不是很友好 wx.setBackgroundTextStyle({ textStyle: 'light' // light or dark }) 方案B（目前最终解决方案） 实现方式：使用多页面方式，结合小程序原生的 tabbar 及自定义 tabbar 实现实现方式：在小程序的 app.json 中设置 tabbar 的样式，保证背景颜色与自定义tabbar的背景颜色相同，如我的项目中，自定义tabbar的背景颜色为 #fff，则 app.json 中配置如下 \"tabBar\": { \"color\": \"#fff\", \"backgroundColor\": \"#fff\", \"borderStyle\": \"white\", \"list\": [ { \"pagePath\": \"pages/news/index\", \"text\": \"\" }, \"pagePath\": \"pages/mine/index\", \"text\": } ] 注意 list 中的设置，不设置 icon 及 text，这样在页面上看，就是小程序的地步，有一个白色的区域，这里我们先把他放在这不管，然后开始写自定义的 tabbar，我这边是以组件的方式实现的，样式这里就不贴出来了，关键在于，默认让这个自定义的 tabbar 隐藏，然后在组件中加如下代码 attached: function () { wx.hideTabBar({ complete: (e) => { if (!this.data.showNav) this.setData({showNav: true}) } }) } 这里的 showNav 即控制自定义 tabbar 是否显示的属性，这样的操作如下： tabbar 组件实例进入页面节点后 执行隐藏原生 tabbar 的方法 隐藏成功后，显示自定义 tabbar 该方式为目前尝试过的所有方式中，用户体验相对来说最好的一个方案，但该方案仍存在缺点： 小程序刚进入时，会显示底部白色区域（原生 tabbar），然后该区域会变为自定义的 tabbar，视觉上会看到一点变化 在安卓下，由于自定义 tabbar 是通过 position: fixed 固定在页面底部的，当页面有小程序原生的刷新功能时，下拉页面会导致底部 tabbar 被推出视野范围，对用户体验有一定影响，这种情况可考虑不适用原生下拉刷新功能，改用自行实现，即可解决 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "}}