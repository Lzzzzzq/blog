{"./":{"url":"./","title":"简介","keywords":"","body":"简介 记录各种鬼东西 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-23 16:35:22 "},"articles/js/":{"url":"articles/js/","title":"js","keywords":"","body":"js Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-23 16:15:42 "},"articles/js/prototype.html":{"url":"articles/js/prototype.html","title":"proto 和 prototype 的关系","keywords":"","body":"proto 和 prototype 的关系 经常有看到对于 proto 和 prototype 的总结，现整理一下 function Foo () {} let foo = new Foo() // Foo 为 foo 的构造函数 foo.__proto__ === Foo.prototype foo.constructor === Foo // Function 为 Foo 的构造函数 Foo.__proto__ === Function.prototype Foo.constructor === Function // Function 由自己创建 Function.__proto__ === Function.prototype Function.constructor === Function // 所有构造函数的 prototype.__proto__ 都指向 Object.prototype Function.prototype.__proto__ === Object.prototype Foo.prototype.__proto__ === Object.prototype Function.prototype.__proto__.constructor === Object // Object.prototype 为所有函数的源头，它的 __proto__ 为 null Object.prototype.__proto__ === null let obj = {} obj.__proto__ === Object.prototype obj.__proto__.__proto__ === null obj.__proto__.constructor === Object obj.__proto__.constructor.__proto__ === Object.__proto__ obj.__proto__.constructor.__proto__.__proto__ === Object.prototype Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-23 16:17:58 "},"articles/nodejs/":{"url":"articles/nodejs/","title":"nodejs","keywords":"","body":"nodejs Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-23 16:21:16 "},"articles/nodejs/koa2middleware.html":{"url":"articles/nodejs/koa2middleware.html","title":"koa2 的中间件","keywords":"","body":"Koa2 中的 Middleware 本文主要讲述 Koa2 中 Middleware ( 中间件 ) 的实现原理。 Middleware 是 Koa 中的而一个比较重要的核心概念，中间件就是类似于一个过滤器一样的东西，是在客户端和应用程序之间处理请求和响应的方法，中间件的执行顺序就像一个洋葱，也可以理解为 V 型，下图应该很常见。 下面通过一些代码展示一下这个洋葱圈的过程。 function a(next) { console.log(1) next() console.log(2) } function b(next) { console.log(3) next() console.log(4) } function c(next) { console.log(5) next() console.log(6) } 如上三个函数，这里我们把他们当成是中间件，先不看其中的 next 的话，依次调用这三个中间件，最后控制台输出的结果应该是： // 方法 a 中 第一段 1 // 方法 a 中 第二段 2 // 方法 b 中 第一段 3 // 方法 b 中 第二段 4 // 方法 c 中 第一段 5 // 方法 c 中 第二段 6 我们反过来将 next 加进去，再按照 Middleware 的方法来执行，最后的结果就会变成： // 方法 a 中 第一段 1 // 方法 b 中 第一段 3 // 方法 c 中 第一段 5 // 方法 c 中 第二段 6 // 方法 b 中 第二段 4 // 方法 a 中 第二段 2 就好像函数执行到 next 的时候就停住了，然后跳到下一个方法执行了，最后都执行完以后，再返回来执行了每个方法的后半段，我们来看一下源码。 function compose(middleware) { return function(context, next) { // last called middleware # let index = -1 return dispatch(0) function dispatch(i) { if (i 我们假设所有的中间件都不存在异步操作，于是把 promise 都去掉，转换成同步的方式。 function compose(middleware) { dispatch(0) function dispatch(i) { var fn = middleware[i] if (!fn) return fn(function() { return dispatch(i + 1) }) } } compose([a, b, c]) 这样就清爽多了，结合这段代码，我们再去看前面的 a，b，c 三个中间件，通过这个 compose，我们可以理解为，当程序执行到 next() 的时候，检查是否有下一段需要执行的代码，这样我们可以理解为，将这三个函数合成了一个函数 function abc() { // 函数 a 的第一段 console.log(1) // next(); // 这里遇到了 next() ，执行下一个函数 // 函数 b 的第一段 console.log(3) // next(); // 这里遇到了 next() ，执行下一个函数 // 函数 c 的第一段 console.log(5) // next(); // 这里遇到了 next() ，但后面没有要执行的函数了 // 函数 c 的第二段 console.log(6) // 函数 b 的第二段 console.log(4) // 函数 a 的第二段 console.log(2) } Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-23 16:31:36 "},"articles/mp/":{"url":"articles/mp/","title":"微信小程序相关","keywords":"","body":"微信小程序 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-23 16:15:38 "},"articles/mp/scenecode.html":{"url":"articles/mp/scenecode.html","title":"跳回 APP 场景值获取","keywords":"","body":"跳回 APP 场景值获取 需求 小程序直接访问时，场景值为 1001，不显示跳回 APP 按钮 小程序通过 APP 分享卡片打开时，场景值为 1036 ，显示跳回 APP 按钮 问题 根据文档中所说，onShow 的回调参数中会带有当前场景值，结果发现 Page 的 onShow 没有回调参数 在 Page 内使用 wx.getLaunchOptionsSync 获取到的场景值不会改变，如果第一次进入小程序时，场景值为 1036，那么后面获取到的场景值都为 1036，导致即使从微信内分享的小程序卡片打开，也同样被认为是从 APP 分享过来的 在 Page 中添加 onAppShow 事件，回调参数中的场景值为正确场景值，然而执行 setData 后，数据更新，但是视图不刷新，已排除 this 指向错误的问题 解决办法 文档描述有误，onShow 只有在 app.js 内，也就是小程序的 App 下，才会有回调参数，此时的回调参数为正确的回调参数，将该参数设置在 App 的全局变量中，然后在各 Page 的 onShow 中，通过 getApp() 来获取场景值并进行 setData 操作，数据更新，视图更新 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-23 16:38:43 "},"articles/mp/tabbar.html":{"url":"articles/mp/tabbar.html","title":"自定义 tabbar 解决方案","keywords":"","body":"自定义tabbar解决方案 背景 用于微信小程序自定义tabbar开发，以解决原生tabbar样式无法高度定制化的情况 需求 使用 wx.switchTab 方式进行跳转 解决网上常见的解决方案中闪屏的情况（使用wx.navigateTo进行跳转） 可自定义样式 实现方案及思路 方案A 实现方式：使用单页面的方式，通过底部的tabbar点击来控制各个视图隐藏与显示的方式来实现实施时遇到的问题：A页面需要小程序原生的下拉刷新功能，B页面不需要下拉刷新功能，由于小程序单独页面的下拉刷新功能需写死在 page 的 json 文件里，无法通过设置动态开关，导致该需求无法很好的实现，后想到了一个弥补措施，即开启页面的下拉刷新功能，在可以下拉刷新的A页面，将原生加载区域的三个点的样式动态设置为与背景颜色相反的颜色，下拉后去请求数据，在不需要下拉刷新功能的B页面，动态修改三个点的样式为与背景相同的颜色，下拉后直接执行下拉的 stop 方法，这样从视觉上看，是没有做下拉刷新的操作了，从体验上来说，还是和下拉刷新时一样，会有一下停顿，对用户体验来说不是很友好 wx.setBackgroundTextStyle({ textStyle: 'light' // light or dark }) 方案B（目前最终解决方案） 实现方式：使用多页面方式，结合小程序原生的 tabbar 及自定义 tabbar 实现实现方式：在小程序的 app.json 中设置 tabbar 的样式，保证背景颜色与自定义tabbar的背景颜色相同，如我的项目中，自定义tabbar的背景颜色为 #fff，则 app.json 中配置如下 \"tabBar\": { \"color\": \"#fff\", \"backgroundColor\": \"#fff\", \"borderStyle\": \"white\", \"list\": [ { \"pagePath\": \"pages/news/index\", \"text\": \"\" }, \"pagePath\": \"pages/mine/index\", \"text\": } ] 注意 list 中的设置，不设置 icon 及 text，这样在页面上看，就是小程序的地步，有一个白色的区域，这里我们先把他放在这不管，然后开始写自定义的 tabbar，我这边是以组件的方式实现的，样式这里就不贴出来了，关键在于，默认让这个自定义的 tabbar 隐藏，然后在组件中加如下代码 attached: function () { wx.hideTabBar({ complete: (e) => { if (!this.data.showNav) this.setData({showNav: true}) } }) } 这里的 showNav 即控制自定义 tabbar 是否显示的属性，这样的操作如下： tabbar 组件实例进入页面节点后 执行隐藏原生 tabbar 的方法 隐藏成功后，显示自定义 tabbar 该方式为目前尝试过的所有方式中，用户体验相对来说最好的一个方案，但该方案仍存在缺点： 小程序刚进入时，会显示底部白色区域（原生 tabbar），然后该区域会变为自定义的 tabbar，视觉上会看到一点变化 在安卓下，由于自定义 tabbar 是通过 position: fixed 固定在页面底部的，当页面有小程序原生的刷新功能时，下拉页面会导致底部 tabbar 被推出视野范围，对用户体验有一定影响，这种情况可考虑不适用原生下拉刷新功能，改用自行实现，即可解决 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-23 16:38:47 "}}