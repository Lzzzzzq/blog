{"./":{"url":"./","title":"简介","keywords":"","body":"简介 记录各种鬼东西 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/js/":{"url":"articles/js/","title":"js","keywords":"","body":"js Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/js/prototype.html":{"url":"articles/js/prototype.html","title":"proto 和 prototype 的关系","keywords":"","body":"proto 和 prototype 的关系 经常有看到对于 proto 和 prototype 的总结，现整理一下 function Foo () {} let foo = new Foo() // Foo 为 foo 的构造函数 foo.__proto__ === Foo.prototype foo.constructor === Foo // Function 为 Foo 的构造函数 Foo.__proto__ === Function.prototype Foo.constructor === Function // Function 由自己创建 Function.__proto__ === Function.prototype Function.constructor === Function // 所有构造函数的 prototype.__proto__ 都指向 Object.prototype Function.prototype.__proto__ === Object.prototype Foo.prototype.__proto__ === Object.prototype Function.prototype.__proto__.constructor === Object // Object.prototype 为所有函数的源头，它的 __proto__ 为 null Object.prototype.__proto__ === null let obj = {} obj.__proto__ === Object.prototype obj.__proto__.__proto__ === null obj.__proto__.constructor === Object obj.__proto__.constructor.__proto__ === Object.__proto__ obj.__proto__.constructor.__proto__.__proto__ === Object.prototype Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/react/":{"url":"articles/react/","title":"React","keywords":"","body":"react Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:47:48 "},"articles/react/why-do-we-write-super-props.html":{"url":"articles/react/why-do-we-write-super-props.html","title":"[转] 为什么我们要写 super(props)","keywords":"","body":"为什么我们要写 super(props) ？ 本文转自：https://overreacted.io/zh-hans/why-do-we-write-super-props/ 首先，在这一生中，super(props) 出现在我代码里的次数比我知道的还要多： class Checkbox extends React.Component { constructor(props) { super(props); this.state = { isOn: true }; } // ... } 当然了，我们可以通过 class fields proposal 来省略这个声明： class Checkbox extends React.Component { state = { isOn: true }; // ... } 早在 2015 年 React 0.13 已经计划支持 。在当时，声明 constructor 和调用 super(props) 一直被视作暂时的解决方案，直到有合适的类字段声明形式。 但在此之前，我们先回到 ES2015 风格的代码： class Checkbox extends React.Component { constructor(props) { super(props); this.state = { isOn: true }; } // ... } 为什么我们要调用 super，我们可以不这么做吗？那么在我们调用它时不传入 props，又会发生什么呢？会有其他的缺省参数吗？接来下我们就解开这一系列谜题。 在 JavaScript 中，super 指的是父类（即超类）的构造函数。（在我们的例子中，它指向了 React.Component 的实现。） 值得注意的是，在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的。JavaScript 不允许这个行为。 class Checkbox extends React.Component { constructor(props) { // &#x1F534; 还不能使用 `this` super(props); // ✅ 现在可以了 this.state = { isOn: true }; } // ... } JavaScript 有足够合理的动机来强制你在接触 this 之前执行父类构造函数。考虑考虑一些类层次结构的东西： class Person { constructor(name) { this.name = name; } } class PolitePerson extends Person { constructor(name) { this.greetColleagues(); // &#x1F534; 这是禁止的，往后见原因 super(name); } greetColleagues() { alert('Good morning folks!'); } } 试想一下，在调用 super 之前使用 this 不被禁止的情况下，一个月后，我们可能在 greetColleagues 打印的消息中使用了 person 的 name 属性： greetColleagues() { alert('Good morning folks!'); alert('My name is ' + this.name + ', nice to meet you!'); } 但是我们并未想起 this.greetColleagues 在 super() 给 this.name 赋值前就已经执行。this.name 此时甚至尚未定义。可以看到，这样的代码难以往下推敲。 为了避免落入这个陷阱，JavaScript 强制你在使用 this 之前先行调用 super。让父类来完成这件事情！： constructor(props) { super(props); // ✅ 能使用 `this` 了 this.state = { isOn: true }; } 这里留下了另一个问题：为什么要传入 props ？ 你或许会想到，为了让 React.Component 构造函数能够初始化 this.props，将 props 传入 super 是必须的： // React 內部 class Component { constructor(props) { this.props = props; // ... } } 这几乎就是真相了 — 确然，它是 这样做 的。 但有些扑朔迷离的是，即便你调用 super() 的时候没有传入 props，你依然能够在 render 函数或其他方法中访问到 this.props。（如果你质疑这个机制，尝试一下即可） 那么这是怎么做到的呢？事实证明，React 在调用构造函数后也立即将 props 赋值到了实例上：** // React 内部 const instance = new YourComponent(props); instance.props = props; 因此即便你忘记了将 props 传给 super()，React 也仍然会在之后将它定义到实例上。这么做是有原因的。 当 React 增加了对类的支持时，不仅仅是为了服务于 ES6。其目标是尽可能广泛地支持类抽象。当时我们 不清楚 ClojureScript，CoffeeScript，ES6，Fable，Scala.js，TypeScript 等解決方案是如何成功的实践组件定义的。因而 React 刻意地没有显式要求调用 super() —— 即便 ES6 自身就包含这个机制。 这意味着你能够用 super() 代替 super(props) 吗？ 最好不要，毕竟这样写在逻辑上并不明确确然，React 会在构造函数执行完毕之后给 this.props 赋值。但如此为之会使得 this.props 在 super 调用一直到构造函数结束期间值为 undefined。 // React 內部 class Component { constructor(props) { this.props = props; // ... } } // 你的程式碼內部 class Button extends React.Component { constructor(props) { super(); // &#x1F62C; 我们忘了传入 props console.log(props); // ✅ {} console.log(this.props); // &#x1F62C; 未定义 } // ... } 如果在构造函数中调用了其他的内部方法，那么一旦出错这会使得调试过程阻力更大。这就是我建议开发者一定执行 super(props) 的原因，即使理论上这并非必要： class Button extends React.Component { constructor(props) { super(props); // ✅ 传入 props console.log(props); // ✅ {} console.log(this.props); // ✅ {} } // ... } 确保了 this.props 在构造函数执行完毕之前已被赋值。 最后，还有一点是 React 爱好者长期以来的好奇之处。 你会发现当你在类中使用 Context API （无论是旧版的 contextTypes 或是在 React 16.6 更新的新版 contextTypes）的时候，context 是作为第二个参数传入构造函数的。 那么为什么我们不能转而写成 super(props, context) 呢？我们当然可以，但 context 的使用频率较低，因而并没有掘这个坑。 class fields proposal 出台后，这些坑大部分都会自然地消失在没有显示的定义构造函数的情况下，以上的属性都会被自动地初始化。这使得像 state = {} 这类表达式能够在需要的情况下引用 this.props 和 this.context 的内容。 然而，有了 Hooks 以后，我们几乎就不需要 super 和 this 了。但那就是另一个下午的茶点了。 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:54:10 "},"articles/react/how-does-react-tell-a-class-from-a-function.html":{"url":"articles/react/how-does-react-tell-a-class-from-a-function.html","title":"[转] React 如何区分 Class 和 Function","keywords":"","body":"React 如何区分 Class 和 Function？ 本文转自：https://overreacted.io/zh-hans/how-does-react-tell-a-class-from-a-function/ 让我们来看一下这个以函数形式定义的 Greeting 组件： function Greeting() { return Hello; } React 也支持将他定义成一个类： class Greeting extends React.Component { render() { return Hello; } } （直到最近，这是使用 state 特性的唯一方式） 当你要渲染一个 组件时，你并不需要关心它是如何定义的： // 是类还是函数 —— 无所谓 但 React 本身 在意其中的差别！ 如果 Greeting 是一个函数，React 需要调用它。 // 你的代码 function Greeting() { return Hello; } // React 内部 const result = Greeting(props); // Hello 但如果 Greeting 是一个类，React 需要先用 new 操作符将其实例化，然后 调用刚才生成实例的 render 方法： // 你的代码 class Greeting extends React.Component { render() { return Hello; } } // React 内部 const instance = new Greeting(props); // Greeting {} const result = instance.render(); // Hello 无论哪种情况 React 的目标都是去获取渲染后的节点（在这个案例中，Hello）。但具体的步骤取决于 Greeting 是如何定义的。 所以 React 是怎么知道某样东西是 class 还是 function 的呢？ 就像我上一篇博客中提到的，你并不需要知道这个才能高效使用 React。 我多年来都不知道这个。请不要把这变成一道面试题。事实上，这篇博客更多的是关于 JavaScript 而不是 React。 这篇博客是写给那些对 React 具体是 如何 工作的表示好奇的读者的。你是那样的人吗？那我们一起深入探讨一下吧。 这将是一段漫长的旅程，系好安全带。这篇文章并没有多少关于 React 本身的信息，但我们会涉及到 new、this、class、箭头函数、prototype、proto、instanceof 等方面，以及这些东西是如何在 JavaScript 中一起工作的。幸运的是，你并不需要在使用 React 时一直想着这些，除非你正在实现 React… （如果你真的很想知道答案，直接翻到最下面。） 首先，我们需要理解为什么把函数和类分开处理很重要。注意看我们是怎么使用 new 操作符来调用一个类的： // 如果 Greeting 是一个函数 const result = Greeting(props); // Hello // 如果 Greeting 是一个类 const instance = new Greeting(props); // Greeting {} const result = instance.render(); // Hello 我们来简单看一下 new 在 JavaScript 是干什么的。 在过去，JavaScript 还没有类。但是，你可以使用普通函数来模拟。具体来讲，只要在函数调用前加上 new 操作符，你就可以把任何函数当做一个类的构造函数来用： // 只是一个函数 function Person(name) { this.name = name; } var fred = new Person('Fred'); // ✅ Person {name: 'Fred'} var george = Person('George'); // &#x1F534; 没用的 现在你依然可以这样写！在 DevTools 里试试吧。 如果你调用 Person('Fred') 时没有加 new，其中的 this 会指向某个全局且无用的东西（比如，window 或者 undefined），因此我们的代码会崩溃，或者做一些像设置 window.name 之类的傻事。 通过在调用前增加 new，我们说：「嘿 JavaScript，我知道 Person 只是个函数，但让我们假装它是个构造函数吧。创建一个 {} 对象并把 Person 中的 this 指向那个对象，以便我可以通过类似 this.name 的形式去设置一些东西，然后把这个对象返回给我。」 这就是 new 操作符所做的事。 var fred = new Person('Fred'); // 和 `Person` 中的 `this` 等效的对象 new 操作符同时也把我们放在 Person.prototype 上的东西放到了 fred 对象上： function Person(name) { this.name = name; } Person.prototype.sayHi = function() { alert('Hi, I am ' + this.name);} var fred = new Person('Fred'); fred.sayHi(); 这就是在 JavaScript 直接支持类之前，人们模拟类的方式。 new 在 JavaScript 中已经存在了好久了，然而类还只是最近的事，它的出现让我们能够重构我们前面的代码以使它更符合我们的本意： class Person { constructor(name) { this.name = name; } sayHi() { alert('Hi, I am ' + this.name); } } let fred = new Person('Fred'); fred.sayHi(); 捕捉开发者的本意是语言和 API 设计中非常重要的一点。 如果你写了一个函数，JavaScript 没办法判断它应该像 alert() 一样被调用，还是应该被视作像 new Person() 一样的构造函数。忘记给像 Person 这样的函数指定 new 会导致令人费解的行为。 类语法允许我们说：「这不仅仅是个函数 —— 这是个类并且它有构造函数」。 如果你在调用它时忘了加 new，JavaScript 会报错： let fred = new Person('Fred'); // ✅ 如果 Person 是个函数：有效 // ✅ 如果 Person 是个类：依然有效 let george = Person('George'); // 我们忘记使用 `new` // &#x1F633; 如果 Person 是个长得像构造函数的方法：令人困惑的行为 // &#x1F534; 如果 Person 是个类：立即失败 这可以帮助我们在早期捕捉错误，而不会遇到类似 this.name 被当成 window.name 对待而不是 george.name 的隐晦错误。 然而，这意味着 React 需要在调用所有类之前加上 new，而不能把它直接当做一个常规的函数去调用，因为 JavaScript 会把它当做一个错误对待！ class Counter extends React.Component { render() { return Hello; } } // &#x1F534; React 不能简单这么做： const instance = Counter(props); 这意味着麻烦。 在我们看到 React 如何处理这个问题之前，很重要的一点就是要记得大部分 React 的用户会使用 Babel 等编译器来编译类等现代化的特性以便能在老旧的浏览器上运行。因此我们需要在我们的设计中考虑编译器。 在 Babel 的早期版本中，类不加 new 也可以被调用。但这个问题已经被修复了 —— 通过生成额外的代码的方式。 function Person(name) { // 稍微简化了一下 Babel 的输出： if (!(this instanceof Person)) { throw new TypeError(\"Cannot call a class as a function\"); } // Our code: this.name = name; } new Person('Fred'); // ✅ OK Person('George'); // &#x1F534; 无法把类当做函数来调用 你或许已经在你构建出来的包中见过类似的代码，这就是那些 _classCallCheck 函数做的事。（你可以通过启用「loose mode」来关闭检查以减小构建包的尺寸，但这或许会使你最终转向真正的原生类时变得复杂） 至此，你应该已经大致理解了调用时加不加 new 的差别： new Person() Person() class ✅ this 是一个 Person 实例 &#x1F534; TypeError function ✅ this 是一个 Person 实例 &#x1F633; this 是 window 或 undefined 这就是 React 正确调用你的组件很重要的原因。如果你的组件被定义为一个类，React 需要使用 new 来调用它。 所以 React 能检查出某样东西是否是类吗？ 没那么容易！即便我们能够在 JavaScript 中区分类和函数，面对被 Babel 等工具处理过的类这还是没用。对浏览器而言，它们只是不同的函数。这是 React 的不幸。 好，那 React 可以直接在每次调用时都加上 new 吗？很遗憾，这种方法并不总是有用。 对于常规函数，用 new 调用会给它们一个 this 作为对象实例。对于用作构造函数的函数（比如我们前面提到的 Person）是可取的，但对函数组件这或许就比较令人困惑了： function Greeting() { // 我们并不期望 `this` 在这里表示任何类型的实例 return Hello; } 这暂且还能忍，还有两个其他理由会扼杀这个想法。 关于为什么总是使用 new 是没用的的第一个理由是，对于原生的箭头函数（不是那些被 Babel 编译过的），用 new 调用会抛出一个错误： const Greeting = () => Hello; new Greeting(); // &#x1F534; Greeting 不是一个构造函数 这个行为是遵循箭头函数的设计而刻意为之的。箭头函数的一个附带作用是它没有自己的 this 值 —— this 解析自离得最近的常规函数： class Friends extends React.Component { render() { const friends = this.props.friends; return friends.map(friend => ); } } OK，所以箭头函数没有自己的 this。但这意味着它作为构造函数是完全无用的！ const Person = (name) => { // &#x1F534; 这么写是没有意义的！ this.name = name; } 因此，JavaScript 不允许用 new 调用箭头函数。如果你这么做，你或许已经犯了错，最好早点告诉你。这和 JavaScript 不让你不加 new 去调用一个类是类似的。 这样很不错，但这也让我们的计划受阻。React 不能简单对所有东西都使用 new，因为会破坏箭头函数！我们可以利用箭头函数没有 prototype 的特点来检测箭头函数，不对它们使用 new： (() => {}).prototype // undefined (function() {}).prototype // {constructor: f} 但这对于被 Babel 编译过的函数是没用的。这或许没什么大不了，但还有另一个原因使得这条路不会有结果。 另一个我们不能总是使用 new 的原因是它会妨碍 React 支持返回字符串或其它原始类型的组件。 function Greeting() { return 'Hello'; } Greeting(); // ✅ 'Hello' new Greeting(); // &#x1F633; Greeting {} 这，再一次，和new 操作符的怪异设计有关。如我们之前所看到的，new 告诉 JavaScript 引擎去创建一个对象，让这个对象成为函数内部的 this，然后把这个对象作为 new 的结果给我们。 然而，JavaScript 也允许一个使用 new 调用的函数返回另一个对象以 覆盖 new 的返回值。或许，这在我们利用诸如「对象池模式」来对组件进行复用时是被认为有用的： // 创建了一个懒变量 zeroVector = null; function Vector(x, y) { if (x === 0 && y === 0) { if (zeroVector !== null) { // 复用同一个实例 return zeroVector; } zeroVector = this; } this.x = x; this.y = y; } var a = new Vector(1, 1); var b = new Vector(0, 0); var c = new Vector(0, 0); // &#x1F632; b === c 然而，如果一个函数的返回值不是一个对象，它会被 new 完全忽略。如果你返回了一个字符串或数字，就好像完全没有 return 一样。 function Answer() { return 42; } Answer(); // ✅ 42 new Answer(); // &#x1F633; Answer {} 当使用 new 调用函数时，是没办法读取原始类型（例如一个数字或字符串）的返回值的。因此如果 React 总是使用 new，就没办法增加对返回字符串的组件的支持！ 这是不可接受的，因此我们必须妥协。 至此我们学到了什么？React 在调用类（包括 Babel 输出的）时需要用 new，但在调用常规函数或箭头函数时（包括 Babel 输出的）不需要用 new，并且没有可靠的方法来区分这些情况。 如果我们没法解决一个笼统的问题，我们能解决一个具体的吗？ 当你把一个组件定义为类，你很可能会想要扩展 React.Component 以便获取内置的方法，比如 this.setState()。 与其试图检测所有的类，我们能否只检测 React.Component 的后代呢？ 剧透：React 就是这么干的。 或许，检查 Greeting 是否是一个 React 组件类的最符合语言习惯的方式是测试 Greeting.prototype instanceof React.Component： class A {} class B extends A {} console.log(B.prototype instanceof A); // true 我知道你在想什么，刚才发生了什么？！为了回答这个问题，我们需要理解 JavaScript 原型。 你或许对「原型链」很熟悉。JavaScript 中的每一个对象都有一个「原型」。当我们写 fred.sayHi() 但 fred 对象没有 sayHi 属性，我们尝试到 fred 的原型上去找 sayHi 属性。要是我们在这儿找不到，就去找原型链的下一个原型 —— fred 的原型的原型，以此类推。 费解的是，一个类或函数的 prototype 属性 并不 指向那个值的原型。我没开玩笑。 function Person() {} console.log(Person.prototype); // &#x1F92A; 不是 Person 的原型 console.log(Person.__proto__); // &#x1F633; Person 的原型 因此「原型链」更像是 __proto__.__proto__.__proto__ 而不是 prototype.prototype.prototype，我花了好几年才搞懂这一点。 那么函数和类的 prototype 属性又是什么？是用 new 调用那个类或函数生成的所有对象的 proto！ function Person(name) { this.name = name; } Person.prototype.sayHi = function() { alert('Hi, I am ' + this.name); } var fred = new Person('Fred'); // 设置 `fred.__proto__` 为 `Person.prototype` 那个 __proto__ 链才是 JavaScript 用来查找属性的： fred.sayHi(); // 1. fred 有 sayHi 属性吗？不。 // 2. fred.__proto__ 有 sayHi 属性吗？是的，调用它！ fred.toString(); // 1. fred 有 toString 属性吗？不。 // 2. fred.__proto__ 有 toString 属性吗？不。 // 3. fred.__proto__.__proto__ 有 toString 属性吗？是的，调用它！ 在实战中，你应该几乎永远不需要直接在代码里动到 __proto__ ，除非你在调试和原型链相关的问题。如果你想让某样东西在 fred.__proto__ 上可用，你应该把它放在 Person.prototype，至少它最初是这么设计的。 __proto__ 属性甚至一开始就不应该被浏览器暴露出来，因为原型链应该被视为一个内部概念，然而某些浏览器增加了 __proto__ 并最终勉强被标准化（但已被废弃并推荐使用 Object.getPrototypeOf()）。 然而一个名叫「原型」的属性却给不了我一个值的「原型」这一点还是很让我困惑（例如，fred.prototype 是未定义的，因为 fred 不是一个函数）。个人观点，我觉得这是即便有经验的开发者也容易误解 JavaScript 原型链的最大原因。 这篇博客很长，是吧？已经到 80% 了，坚持住。 我们知道当说 obj.foo 的时候，JavaScript 事实上会沿着 obj, obj.__proto__, obj.__proto__.__proto__ 等等一路寻找 foo。 在使用类时，你并非直接面对这一机制，但 extends 的原理依然是基于这项老旧但有效的原型链机制。这也是的我们的 React 类实例能够访问如 setState 这样方法的原因： class Greeting extends React.Component { render() { return Hello; } } let c = new Greeting(); console.log(c.__proto__); // Greeting.prototype console.log(c.__proto__.__proto__); // React.Component.prototype console.log(c.__proto__.__proto__.__proto__); // Object.prototype c.render(); // 在 c.__proto__ (Greeting.prototype) 上找到 c.setState(); // 在 c.__proto__.__proto__ (React.Component.prototype) 上找到 c.toString(); // 在 c.__proto__.__proto__.__proto__ (Object.prototype) 上找到 换句话说，当你在使用类的时候，实例的 proto 链「镜像」了类的层级结构： // `extends` 链 Greeting → React.Component → Object (间接的) // `__proto__` 链 new Greeting() → Greeting.prototype → React.Component.prototype → Object.prototype 2 条链。 既然 __proto__ 链镜像了类的层级结构，我们可以检查一个 Greeting 是否扩展了 React.Component，我们从 Greeting.prototype 开始，一路沿着 __proto__ 链： // `__proto__` chain new Greeting() → Greeting.prototype // &#x1F575;️ 我们从这儿开始 → React.Component.prototype // ✅ 找到了！ → Object.prototype 方便的是，x instanceof Y 做的就是这类搜索。它沿着 x.__proto__ 链寻找 Y.prototype 是否在那儿。 通常，这被用来判断某样东西是否是一个类的实例： let greeting = new Greeting(); console.log(greeting instanceof Greeting); // true // greeting (我们从这儿开始) // .__proto__ → Greeting.prototype (✅ 找到了！) // .__proto__ → React.Component.prototype // .__proto__ → Object.prototype console.log(greeting instanceof React.Component); // true // greeting (我们从这儿开始) // .__proto__ → Greeting.prototype // .__proto__ → React.Component.prototype (✅ 找到了！) // .__proto__ → Object.prototype console.log(greeting instanceof Object); // true // greeting (我们从这儿开始) // .__proto__ → Greeting.prototype // .__proto__ → React.Component.prototype // .__proto__ → Object.prototype (✅ 找到了！) console.log(greeting instanceof Banana); // false // greeting (我们从这儿开始) // .__proto__ → Greeting.prototype // .__proto__ → React.Component.prototype // .__proto__ → Object.prototype (&#x1F645;‍ 没找到！) 但这用来判断一个类是否扩展了另一个类还是有效的： console.log(Greeting.prototype instanceof React.Component); // greeting // .__proto__ → Greeting.prototype ( 我们从这儿开始) // .__proto__ → React.Component.prototype (✅ 找到了！) // .__proto__ → Object.prototype 这种检查方式就是我们判断某样东西是一个 React 组件类还是一个常规函数的方式。 然而 React 并不是这么做的。 &#x1F633; 关于 instanceof 解决方案有一点附加说明，当页面上有多个 React 副本，并且我们要检查的组件继承自 另一个 React 副本的 React.Component 时，这种方法是无效的。在一个项目里混合多个 React 副本是不好的，原因有很多，但站在历史角度来看，我们试图尽可能避免问题。（有了 Hooks，我们或许得强制避免重复。） 另一点启发可以是去检查原型链上的 render 方法。然而，当时还不确定组件的 API 会如何演化。每一次检查都有成本，所以我们不想再多加了。如果 render 被定义为一个实例方法，例如使用类属性语法，这个方法也会失效。 因此, React 为基类增加了一个特别的标记。React 检查是否有这个标记，以此知道某样东西是否是一个 React 组件类。 最初这个标记是在 React.Component 这个基类自己身上： // React 内部 class Component {} Component.isReactClass = {}; // 我们可以像这样检查它 class Greeting extends Component {} console.log(Greeting.isReactClass); // ✅ 是的 然而，有些我们希望作为目标的类实现并没有复制静态属性（或设置非标准的 __proto__），标记也因此丢失。 这也是为什么 React 把这个标记移动到了 React.Component.prototype： // React 内部 class Component {} Component.prototype.isReactComponent = {}; // 我们可以像这样检查它 class Greeting extends Component {} console.log(Greeting.prototype.isReactComponent); // ✅ 是的 说真的这就是全部了。 你或许奇怪为什么是一个对象而不是一个布尔值。实战中这并不重要，但早期版本的 Jest（在 Jest 商品化之前）是默认开始自动模拟功能的，生成的模拟数据省略掉了原始类型属性，破坏了检查。谢了，Jest。 一直到今天，React 都在用 isReactComponent 进行检查。 如果你不扩展 React.Component，React 不会在原型上找到 isReactComponent，因此就不会把组件当做类处理。现在你知道为什么解决 Cannot call a class as a function 错误的得票数最高的答案是增加 extends React.Component。最后，我们还增加了一项警告，当 prototype.render 存在但 prototype.isReactComponent 不存在时会发出警告。 你或许会觉得这个故事有一点「标题党」。 实际的解决方案其实真的很简单，但我花了大量的篇幅在转折上来解释为什么 React 最终选择了这套方案，以及还有哪些候选方案。 以我的经验来看，设计一个库的 API 也经常会遇到这种情况。为了一个 API 能够简单易用，你经常需要考虑语义化（可能的话，为多种语言考虑，包括未来的发展方向）、运行时性能、有或没有编译时步骤的工程效能、生态的状态以及打包方案、早期的警告，以及很多其它问题。最终的结果未必总是最优雅的，但必须要是可用的。 如果最终的 API 成功的话，它的用户 永远不必思考这一过程。他们只需要专心创建应用就好了。 但如果你同时也很好奇…知道它是怎么工作的也是极好的。 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 16:40:44 "},"articles/react/how-does-setstate-know-what-to-do.html":{"url":"articles/react/how-does-setstate-know-what-to-do.html","title":"[转] setState 如何知道该做什么","keywords":"","body":"setState 如何知道该做什么？ 当你在组件中调用setState的时候，你认为发生了些什么？ import React from 'react'; import ReactDOM from 'react-dom'; class Button extends React.Component { constructor(props) { super(props); this.state = { clicked: false }; this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState({ clicked: true }); } render() { if (this.state.clicked) { return Thanks; } return ( Click me! ); } } ReactDOM.render(, document.getElementById('container')); 当然是：React根据下一个状态{clicked：true}重新渲染组件，同时更新DOM以匹配返回的Thanks元素啊。 看起来很直白。但是等等，是 React做了这些吗？还是React DOM？ 更新DOM听起来像是React DOM的职责所在。但是我们调用的是this.setState()，而没有调用 任何来自React DOM的东西。 而且我们组件的父类React.Component也是在React本身定义的。 所以存在于React.Component 内部的setState()是如何更新DOM的呢？ 免责声明: 就像本博客里绝大多数 其他的 帖子一样， 其实你不需要知道其中的任何知识，就可以有效地使用React。 本文面向的是那些想要了解React背后原理的人。而这完全是可选的！ 我们或许会认为：React.Component类包含了DOM 更新的逻辑。 但是如果是这样的话，this.setState()又如何能在其他环境下使用呢？举个例子，React Native app中的组件也是 继承自React.Component。他们依然可以像我们在上面做的那样调用this.setState()，而且React Native 渲染的是安卓和iOS原生的 界面而不是DOM。 你或许对React Test Renderer 或是 Shallow Renderer很熟悉。这些测试策略能让你 正常渲染组件， 也可以在组件内部调用this.setState()。但是这两个渲染器并不与DOM相关。 如果你曾使用过一些渲染器像React ART，你也许也知道在一个页面中我们是可以使用多个渲染器的。（举个例子，ART 组件在React DOM树的内部起作用。）这使得全局标志或变量无法维持。 因此，React.Component以某种未知的方式将处理 状态（state）更新的任务委托给了特定平台的代码。在我们理解这些是如何发生的之前，让我们深挖一下包（packages）是如何分离的以及为什么这样分离。 有一个很常见的误解就是React“引擎”是存在于react包里面的。 然而事实并非如此。 实际上从React 0.14我们将代码拆分成多个包以来，react包故意 只暴露一些定义组件的API。绝大多数React的 实现都存在于“渲染器（renderers）”中。 react-dom、react-dom/server、 react-native、 react-test-renderer、 react-art都是常见的渲染器（当然你也可以创建属于你的渲染器）。 这就是为什么不管你的目标平台是什么，react包都是可用的。从react包中导出的一切，比如React.Component、React.createElement、 React.Children 和（最终的）Hooks，都是独立于目标平台的。无论你是运行React DOM，还是 React DOM Server,或是 React Native，你的组件都可以使用同样的方式导入和使用。 相比之下，渲染器包 暴露的都是特定平台的API ，比如说：ReactDOM.render()，可以让你将React层次结构（hierarchy）挂载进一个DOM节点。每一种渲染器都提供了类似的API。理想状况下，绝大多数组件都不应该从渲染器中导入任何东西。只有这样，组件才会更加灵活。 和大多数人现在想的一样，React “引擎”就是存在于各个渲染器的内部。很多渲染器包含一份 同样代码的复制 —— 我们称为“协调器”(“reconciler”)。构建步骤(build step)将协调器代码和渲染器代码 平滑地整合成一个高度优化的捆绑包（bundle）以获得更高的性能。（代码复制通常来说不利于控制捆绑包的大小，但是 绝大多数React用户同一时间只会选用一个渲染器，比如说react-dom。） 这里要注意的是： react包仅仅是让你使用 React 的特性，但是它完全不知道这些特性是如何实现的。而渲染器包(react-dom、react-native等)提供了React特性 的实现以及平台特定的逻辑。这其中的有些代码是共享的(“协调 器”)，但是这就涉及到各个渲染器的实现细节了。 现在我们知道为什么当我们想使用新特性时，react 和 react-dom都需要被更新。举个例子，当React 16.3添加了Context API，React.createContext()API会被React包暴露出来。 但是React.createContext() 其实并没有实现 context。因为在React DOM 和 React DOM Server 中同样一个 API 应当有不同的实现。所以createContext()只返回了一些普通对象： // 简化版代码 function createContext(defaultValue) { let context = { _currentValue: defaultValue, Provider: null, Consumer: null }; context.Provider = { $$typeof: Symbol.for('react.provider'), _context: context }; context.Consumer = { $$typeof: Symbol.for('react.context'), _context: context, }; return context; } 当你在代码中使用 或 的时候， 是渲染器 决定如何处理这些接口。React DOM也许用某种方式追踪context的值，但是React DOM Server用的可能是另一种不同的方式。 所以，如果你将react升级到了16.3+，但是不更新react-dom，那么你就使用了一个尚不知道 Provider 和 Consumer类型的渲染器。这就是为什么一个老版本的react-dom会 报错说这些类型是无效的。 同样的警告也会出现在React Native中。然而不同于React DOM的是， 一个React新版本的发布并不立即“强制”发布新的 React Native 版本。他们具有独立的发布日程。 每隔几周，更新后的渲染器代码就会单独同步到React Native仓库。这就是相比 React DOM，React Native 特性可用时间不同的原因。 好吧，所以现在我们知道了react包并不包含任何有趣的东西， 除此之外，具体的实现也 是存在于react-dom，react-native之类的渲染器中。但是这并没有回答我们的问题。React.Component中的setState()如何与正确的渲染器“对话”？ 答案是：每个渲染器都在已创建的类上设置了一个特殊的字段。这个字段叫做updater。这并不是你要设置的的东西——而是，React DOM、React DOM Server 或 React Native在创建完你的 类的实例之后会立即设置的东西： // React DOM 内部 const inst = new YourComponent(); inst.props = props; inst.updater = ReactDOMUpdater; // React DOM Server 内部 const inst = new YourComponent(); inst.props = props; inst.updater = ReactDOMServerUpdater; // React Native 内部 const inst = new YourComponent(); inst.props = props; inst.updater = ReactNativeUpdater; 查看 React.Component中setState的实现， setState所做的一切就是委托渲染器创建这个组件的实例： // 适当简化的代码 setState(partialState, callback) { // 使用`updater`字段回应渲染器！ this.updater.enqueueSetState(this, partialState, callback); } React DOM Server 也许想 忽略一个状态更新 并且警告你，而React DOM 与 React Native却想要让他们协调器（reconciler）的副本处理它。 这就是this.setState()尽管定义在React包中，却能够 更新DOM的原因。它 读取由React DOM设置的this.updater`，让React DOM安排并处理更新。 现在关于类的部分我们已经知道了，那关于Hooks的呢？ 当人们第一次看见Hooks proposal API， 他们 可能经常会想： useState是怎么 “知道要做什么”的？然后假设它比那些 包含this.setState()的React.Component类更“神奇”。 但是正如我们今天所看到的，基类中setState()的执行一直以来都是一种错觉。它除了将调用转发给当前的渲染器外，什么也没做 。useState Hook也是做了同样的事情。 Hooks使用了一个“dispatcher”对象，代替了updater字段。当你调用React.useState() 、React.useEffect()、 或者其他内置的Hook时，这些调用被转发给了当前的dispatcher。 // React内部(适当简化) const React = { // 真实属性隐藏的比较深，看你能不能找到它！ __currentDispatcher: null, useState(initialState) { return React.__currentDispatcher.useState(initialState); }, useEffect(initialState) { return React.__currentDispatcher.useEffect(initialState); }, // ... }; 各个渲染器会在渲染你的组件之前设置dispatcher： // React DOM 内部 const prevDispatcher = React.__currentDispatcher; React.__currentDispatcher = ReactDOMDispatcher; let result; try { result = YourComponent(props); } finally { // 恢复原状 React.__currentDispatcher = prevDispatcher; } 举个例子， React DOM Server的实现是在 这里，还有就是React DOM 和 React Native共享的协调器的实现在这里。 这就是为什么像react-dom这样的渲染器需要 访问那个你调用Hooks的react包。否则你的组件将不会 “看见”dispatcher！如果在一个组件树中存在React的多个副本， 也许并不会这样。但是，这总是导致了一些模糊的错误，因此Hooks会强迫你在出现问题之前解决包的重复问题。 在高级工具用例中，你可以 在技术上覆盖dispatcher，尽管我们不鼓励这种操作。（对于__currentDispatcher这个名字我撒谎了，但是你可以在React仓库中找到真实的名字。） 比如说， React DevTools将会使用 一个专门定制的dispatcher通过捕获JavaScript堆栈跟踪来观察Hooks树。请勿模仿。 这也意味着Hooks 本质上并没有与React绑定在一起。如果未来有更多的库想要重用同样的原生的Hooks, 理论上来说dispatcher可以 移动到一个分离的包中，然后暴露成一个一等（first-class）的API，然后给它起一个不那么“吓人 ”的名字。但是在实践中，我们会尽量 避免过早抽象，直到需要它为止。 updater字段和__currentDispatcher对象都是称为依赖注入的通用编程原则的形式。在这两种情况下，渲染器将诸如setState之类的功能的实现“注入”到通用的React包中，以使组件更具声明性。 使用React时，你无需考虑这其中的原理。我们希望React用户花更多时间考虑他们的应用程序代码，而不是像依赖注入这样的抽象概念。但是如果你想知道this.setState()或useState()是如何知道该做什么的，我希望这篇文章会有所帮助。 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 16:42:43 "},"articles/nodejs/":{"url":"articles/nodejs/","title":"nodejs","keywords":"","body":"nodejs Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/nodejs/koa2middleware.html":{"url":"articles/nodejs/koa2middleware.html","title":"koa2 的中间件","keywords":"","body":"Koa2 中的 Middleware 本文主要讲述 Koa2 中 Middleware ( 中间件 ) 的实现原理。 Middleware 是 Koa 中的而一个比较重要的核心概念，中间件就是类似于一个过滤器一样的东西，是在客户端和应用程序之间处理请求和响应的方法，中间件的执行顺序就像一个洋葱，也可以理解为 V 型，下图应该很常见。 下面通过一些代码展示一下这个洋葱圈的过程。 function a(next) { console.log(1) next() console.log(2) } function b(next) { console.log(3) next() console.log(4) } function c(next) { console.log(5) next() console.log(6) } 如上三个函数，这里我们把他们当成是中间件，先不看其中的 next 的话，依次调用这三个中间件，最后控制台输出的结果应该是： // 方法 a 中 第一段 1 // 方法 a 中 第二段 2 // 方法 b 中 第一段 3 // 方法 b 中 第二段 4 // 方法 c 中 第一段 5 // 方法 c 中 第二段 6 我们反过来将 next 加进去，再按照 Middleware 的方法来执行，最后的结果就会变成： // 方法 a 中 第一段 1 // 方法 b 中 第一段 3 // 方法 c 中 第一段 5 // 方法 c 中 第二段 6 // 方法 b 中 第二段 4 // 方法 a 中 第二段 2 就好像函数执行到 next 的时候就停住了，然后跳到下一个方法执行了，最后都执行完以后，再返回来执行了每个方法的后半段，我们来看一下源码。 function compose(middleware) { return function(context, next) { // last called middleware # let index = -1 return dispatch(0) function dispatch(i) { if (i 我们假设所有的中间件都不存在异步操作，于是把 promise 都去掉，转换成同步的方式。 function compose(middleware) { dispatch(0) function dispatch(i) { var fn = middleware[i] if (!fn) return fn(function() { return dispatch(i + 1) }) } } compose([a, b, c]) 这样就清爽多了，结合这段代码，我们再去看前面的 a，b，c 三个中间件，通过这个 compose，我们可以理解为，当程序执行到 next() 的时候，检查是否有下一段需要执行的代码，这样我们可以理解为，将这三个函数合成了一个函数 function abc() { // 函数 a 的第一段 console.log(1) // next(); // 这里遇到了 next() ，执行下一个函数 // 函数 b 的第一段 console.log(3) // next(); // 这里遇到了 next() ，执行下一个函数 // 函数 c 的第一段 console.log(5) // next(); // 这里遇到了 next() ，但后面没有要执行的函数了 // 函数 c 的第二段 console.log(6) // 函数 b 的第二段 console.log(4) // 函数 a 的第二段 console.log(2) } Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/mp/":{"url":"articles/mp/","title":"微信小程序相关","keywords":"","body":"微信小程序 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/mp/scenecode.html":{"url":"articles/mp/scenecode.html","title":"跳回 APP 场景值获取","keywords":"","body":"跳回 APP 场景值获取 需求 小程序直接访问时，场景值为 1001，不显示跳回 APP 按钮 小程序通过 APP 分享卡片打开时，场景值为 1036 ，显示跳回 APP 按钮 问题 根据文档中所说，onShow 的回调参数中会带有当前场景值，结果发现 Page 的 onShow 没有回调参数 在 Page 内使用 wx.getLaunchOptionsSync 获取到的场景值不会改变，如果第一次进入小程序时，场景值为 1036，那么后面获取到的场景值都为 1036，导致即使从微信内分享的小程序卡片打开，也同样被认为是从 APP 分享过来的 在 Page 中添加 onAppShow 事件，回调参数中的场景值为正确场景值，然而执行 setData 后，数据更新，但是视图不刷新，已排除 this 指向错误的问题 解决办法 文档描述有误，onShow 只有在 app.js 内，也就是小程序的 App 下，才会有回调参数，此时的回调参数为正确的回调参数，将该参数设置在 App 的全局变量中，然后在各 Page 的 onShow 中，通过 getApp() 来获取场景值并进行 setData 操作，数据更新，视图更新 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "},"articles/mp/tabbar.html":{"url":"articles/mp/tabbar.html","title":"自定义 tabbar 解决方案","keywords":"","body":"自定义tabbar解决方案 背景 用于微信小程序自定义tabbar开发，以解决原生tabbar样式无法高度定制化的情况 需求 使用 wx.switchTab 方式进行跳转 解决网上常见的解决方案中闪屏的情况（使用wx.navigateTo进行跳转） 可自定义样式 实现方案及思路 方案A 实现方式：使用单页面的方式，通过底部的tabbar点击来控制各个视图隐藏与显示的方式来实现实施时遇到的问题：A页面需要小程序原生的下拉刷新功能，B页面不需要下拉刷新功能，由于小程序单独页面的下拉刷新功能需写死在 page 的 json 文件里，无法通过设置动态开关，导致该需求无法很好的实现，后想到了一个弥补措施，即开启页面的下拉刷新功能，在可以下拉刷新的A页面，将原生加载区域的三个点的样式动态设置为与背景颜色相反的颜色，下拉后去请求数据，在不需要下拉刷新功能的B页面，动态修改三个点的样式为与背景相同的颜色，下拉后直接执行下拉的 stop 方法，这样从视觉上看，是没有做下拉刷新的操作了，从体验上来说，还是和下拉刷新时一样，会有一下停顿，对用户体验来说不是很友好 wx.setBackgroundTextStyle({ textStyle: 'light' // light or dark }) 方案B（目前最终解决方案） 实现方式：使用多页面方式，结合小程序原生的 tabbar 及自定义 tabbar 实现实现方式：在小程序的 app.json 中设置 tabbar 的样式，保证背景颜色与自定义tabbar的背景颜色相同，如我的项目中，自定义tabbar的背景颜色为 #fff，则 app.json 中配置如下 \"tabBar\": { \"color\": \"#fff\", \"backgroundColor\": \"#fff\", \"borderStyle\": \"white\", \"list\": [ { \"pagePath\": \"pages/news/index\", \"text\": \"\" }, \"pagePath\": \"pages/mine/index\", \"text\": } ] 注意 list 中的设置，不设置 icon 及 text，这样在页面上看，就是小程序的地步，有一个白色的区域，这里我们先把他放在这不管，然后开始写自定义的 tabbar，我这边是以组件的方式实现的，样式这里就不贴出来了，关键在于，默认让这个自定义的 tabbar 隐藏，然后在组件中加如下代码 attached: function () { wx.hideTabBar({ complete: (e) => { if (!this.data.showNav) this.setData({showNav: true}) } }) } 这里的 showNav 即控制自定义 tabbar 是否显示的属性，这样的操作如下： tabbar 组件实例进入页面节点后 执行隐藏原生 tabbar 的方法 隐藏成功后，显示自定义 tabbar 该方式为目前尝试过的所有方式中，用户体验相对来说最好的一个方案，但该方案仍存在缺点： 小程序刚进入时，会显示底部白色区域（原生 tabbar），然后该区域会变为自定义的 tabbar，视觉上会看到一点变化 在安卓下，由于自定义 tabbar 是通过 position: fixed 固定在页面底部的，当页面有小程序原生的刷新功能时，下拉页面会导致底部 tabbar 被推出视野范围，对用户体验有一定影响，这种情况可考虑不适用原生下拉刷新功能，改用自行实现，即可解决 Copyright © lzzzzzq 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:25:20 "}}